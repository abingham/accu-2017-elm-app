{
    "presenters": [
  {
    "bio": "Niall Douglas is a lead author of WiP Boost.AFIO v2, Boost.Outcome, Boost.KernelTest and Boost-lite. He has\nbeen the lead Google Summer of Code administrator for Boost since 2014. He is an Affiliate Researcher with\nthe Waterloo Research Institute for Complexity and Innovation at the University of Waterloo, Canada, and\nholds postgraduate qualifications in Business Information Systems and Educational and Social Research as\nwell as a second undergraduate degree double majoring in Economics and Management. He has been using Boost\nsince 2002 and was the ISO SC22 (Programming Languages) mirror convener for the Republic of Ireland\n2011-2012. He formerly worked for BlackBerry 2012-2013 in their Platform Development group, and was formerly\nthe Chief Software Architect of the Fuel and Hydraulic Test Benches of the EuroFighter defence aircraft. He\nis presently out of contract.\n",
    "country": "IRL",
    "first_name": "Niall",
    "id": 3,
    "last_name": "Douglas",
    "state": "IE-M"
  },
  {
    "bio": "Louis is a math and computer science enthusiast with interest in {cpp} (meta)programming, functional\nprogramming, domain specific languages and related subjects. He is an active member of the Boost community,\nand recently wrote the Boost.Hana metaprogramming library. He works at https://a9.com[A9], writing high\nquality {cpp} libraries and applications to power Amazon\u2019s search engine.\n",
    "country": "USA",
    "first_name": "Louis",
    "id": 4,
    "last_name": "Dionne",
    "state": "US-CA"
  },
  {
    "bio": "Consultant, coach, designer, analyst and developer for over 30 years.\n\nSeb has been involved in the full development lifecycle with experience that ranges from Architecture to Support, from BASIC to Ruby. He\u2019s a partner in Cucumber Limited, who help teams adopt and refine their agile practices, with a particular focus on collaboration and automated testing.\n\nRegular speaker at conferences and occasional contributor to software journals. Contributing author to \u201c97 Things Every Programmer Should Know\u201d (O\u2019Reilly) and lead author of \u201cThe Cucumber for Java Book\u201d (Pragmatic Programmers).\n\nHe blogs at https://cucumber.io and tweets as @sebrose.",
    "country": "GBR",
    "first_name": "Seb",
    "id": 5,
    "last_name": "Rose",
    "state": "GB-SCT"
  },
  {
    "bio": "Bj\u00f6rn wrote his first program in 1980. After completing his MSc in CS and Engineering in 1994, programming\nhas been the primary source of income, mostly from writing embedded software for communications systems. He\nhas been working for a while at Net Insight, where he wears many hats, including mentor, trouble shooter,\nnetwork communications expert, software architect and programmer; the latter in increasingly modern C++.\n\nOccasionally Bj\u00f6rn has been seen tinkering with unorthodox software constructs, pondering \"what can be done\nwith this?\" He lives in Stockholm.\n",
    "country": "SWE",
    "first_name": "Bj\u00f6rn",
    "id": 6,
    "last_name": "Fahller",
    "state": "SE-AB"
  },
  {
    "bio": "Alan is an experienced and effective proponent of the craft of software development. Interested in development processes, tools, design and coding techniques. His expertise covers a range of programming languages, tools and platforms. He is a long term C++ user, has been Chair of the ACCU and a member of the BSI C++ Panel.\r\n\r\nHe is currently working in C++ with a team of open source developers on \"Mir\" (a new Linux display server - https://wiki.ubuntu.com/Mir).\r\n\r\nHe has a BSC in Mathematics and has published articles in ACCU's Overload and C Vu, C/C++ Users Journal, Java Report, and EXE. Contributor to \"97 Things Every Programmer Should Know\".",
    "country": "GBR",
    "first_name": "Alan",
    "id": 9,
    "last_name": "Griffiths",
    "state": "GB-ENG"
  },
  {
    "bio": "Paul has a software development background, starting his career in Logica developing the BBC Domesday Project. He has spent the last 20 years working within investment banking, as a C/C++ developer and technology lead, and now as a principal in Mosaic Financial Markets, a specialist consultancy company.\r\n\r\nPaul has led the delivery of front-to-back derivatives systems and has extensive experience designing and building both in-house and vendor-based trading/risk management systems. His recent consulting engagements include interim leadership of delivery teams, building technology strategy and enterprise architecture, business process re-engineering, and program management.",
    "country": "GBR",
    "first_name": "Paul",
    "id": 10,
    "last_name": "Cunnell",
    "state": "GB-ENG"
  },
  {
    "bio": "As a technician in the 80\u2019s, Chris found himself increasingly automating laboratory tests when someone told him what he was actually doing was programming. As this was rather fun, Chris became a software engineer, architect, then agile methodology and design consultant and trainer, before joining the University of the West of England, Bristol in 2002. He applied his software development experience to artificial intelligence, and in 2011 obtained his PhD in interactive, evolutionary computation for software design. Chris now actively researches in the field of Search-Based Software Engineering (SBSE); his research interests can be found at http://www.cems.uwe.ac.uk/~clsimons/\n\n",
    "country": "GBR",
    "first_name": "Christopher",
    "id": 11,
    "last_name": "Simons",
    "state": "GB-ENG"
  },
  {
    "bio": "Andy Balaam loves to code, and loves to learn new programming languages.  He blogs and makes videos on these topics at https://artificialworlds.net/blog",
    "country": "GBR",
    "first_name": "Andy",
    "id": 14,
    "last_name": "Balaam",
    "state": "GB-ENG"
  },
  {
    "bio": "I have over 30 years experience in IT, using a variety of languages and platforms and have experienced working for a number of different companies over the years.\r\nIn 1989 I became a contract computer programmer and have successfully managed to remain at the technical end of IT ever since;\r\nmy recent work has mostly been in C++ and Java, on Windows and Linux.\r\n\r\nI have been a member of ACCU since 1999; I currently run the Code Critique section of CVu and also write the occasional article.\r\n\r\nI am a member of the BSI C++ panel, catchily known as IST/5/-/21, and have represented the UK at recent C++ ISO standards meetings.",
    "country": "GBR",
    "first_name": "Roger",
    "id": 15,
    "last_name": "Orr",
    "state": "GB-ENG"
  },
  {
    "bio": "Matthew is a 3rd generation programmer and has been programming since the age of 6. He's been coding in C and C++ for over 20 years, professionally for 15 years and fell in love with embedded software a decade ago. He's now having a lot of fun leading a team at a progressive, Agile embedded software company in Cornwall (Bluefruit).",
    "country": "GBR",
    "first_name": "Matthew",
    "id": 16,
    "last_name": "Dodkins",
    "state": "GB-ENG"
  },
  {
    "bio": "Software engineer with 10 years experience spanning a wide range of problems and languages, with an overall focus on systems level code in C/C++. This has ranged from embedded C firmware development for high-performance network switches, to the implementation of a distributed analytical SQL database. Additionally, a stint as an ASIC verification engineer has led to an unhealthy paranoia when it comes testing software. Having lost many hours debugging deadlocks and memory corruptions, is most content when able to solve complex problems with the intelligible, uncomplicated code which is easily understood by others.\r\n\r\nProud of having only ever worked for start-up companies, was mad enough to work for a third, currently developing data centre monitoring and distributed application profiling solutions for OpenStack based HPC environments. Regular attendee of the ACCU Bristol meet-up group. Dislikes include scope creep, buzzwords and marzipan.\r\n",
    "country": "GBR",
    "first_name": "Steven",
    "id": 17,
    "last_name": "Simpson",
    "state": "GB-ENG"
  },
  {
    "bio": "A C/C++ fan since university, Anastasia has been creating real-time *nix-based systems and pushing them to production for 8 years. She has a passion for networking algorithms (especially congestion problems and network management protocols) and embedded programming, and believes in good tooling. Now she is a part of the JetBrains team working as a Product Marketing Manager for CLion, a cross-platform C/C++ IDE.",
    "country": "RUS",
    "first_name": "Anastasia",
    "id": 18,
    "last_name": "Kazakova",
    "state": "RU-SPE"
  },
  {
    "bio": "Odin Holmes has been programming bare metal embedded systems for 15+ \nyears and as any honest nerd admits most of that time was spent \ndebugging his stupid mistakes. With the advent of the 100x speed up of \ntemplate metaprogramming provided by C++11 his current mission began: \nteach the compiler to find his stupid mistakes at compile time so he has \nmore free time for even more template metaprogramming. Odin Holmes is \nthe author of the Kvasir.io library, a DSL which wraps bare metal \nspecial function register interactions allowing full static checking and \na considerable efficiency gain over common practice. Along the way he \nhas discovered many patterns and improvements in expression templates, \nthe brigand MPL library, named parameters, policy based class design etc.",
    "country": "DEU",
    "first_name": "Odin",
    "id": 19,
    "last_name": "Holmes",
    "state": "DE-NW"
  },
  {
    "bio": "Neil is a senior solutions architect within the Global Markets division at Credit Suisse and co-chair of the FIX Protocol Limited working group for clock synchronisation. Throughout his career, Neil has been involved with latency sensitive systems, designing and implementing ultra-low latency venue connectivity for both market data and transactions. His experience, as a subject matter expert for exchange connectivity, has involved him in a range of industry initiatives and working groups. Neil is a member of the BSI panel for C++ and contributor to the ISO SG14 low latency C++ study group.",
    "country": "GBR",
    "first_name": "Neil",
    "id": 20,
    "last_name": "Horlock",
    "state": "GB-ENG"
  },
  {
    "bio": "Robert Chatley is a Principal Teaching Fellow in Software Engineering at Imperial College London. Commercially he works as a consultant, coach and trainer with a focus on agile development. Robert has worked in many companies from startups to multinationals, including working as an engineer at Google, and also as a technical lead at Kizoom, one of the earliest companies in the UK employing XP at scale. He has chaired the XPDay conference, and acted as programme chair for the SPA conference. Robert holds an MEng degree in Information Systems Engineering and PhD in Software Engineering from Imperial College London.",
    "country": "GBR",
    "first_name": "Robert",
    "id": 21,
    "last_name": "Chatley",
    "state": "GB-ENG"
  },
  {
    "bio": "I'm a software consultant specializing in practice, process, test driven development, and complex-adaptive systems-thinking. Hire me!\r\nI'm 30 years old (hex) and I've loved software since I was 10 (decimal).\r\nI built cyber-dojo.org to promote deliberate practice for software developers.\r\nI've worked with Accenture, Aviva, Cisco, Ericsson, Friends Provident, HP, Microsoft, Opera, Ordnance Survey, RBS, Reuters, Renault F1, Schlumberger, Tandberg and many many more.\r\nIf you don't like my work I won't invoice you.\r\nI'm the co-author (with Olve Maudal) of the Deep C/C++ slide deck (over 600,000 views)\r\nI'm the ex ECMA Task Group 2 C# convenor.\r\nI've had some C# books published.\r\nI'm the ex ACCU conference chairman.\r\nI'm married to the beautiful Natalie, and proud father of Ellie, Penny and Patrick.\r\nI love coarse fishing and salmon fishing.\r\nI live in Somerset, England.\r\nOn twitter I'm @JonJagger",
    "country": "GBR",
    "first_name": "Jon",
    "id": 22,
    "last_name": "Jagger",
    "state": "GB-ENG"
  },
  {
    "bio": "Stephen Kelly has been working with C++ as a Software Engineer for almost 10 years. After starting out contributing to KDE applications and libraries, he subsequently became focused on the dependencies of KDE. \r\n\r\nStephen worked as a Qt professional in Berlin for 7 years and became a maintainer in the upstream Qt Project organization. \r\n\r\nIn parallel, Stephen became the top contributor to CMake over many releases and more than 4 years. He designed and implemented the central concepts and new APIs which aim to make CMake easier to work with, more extensible and more modular for users.\r\n\r\nStephen now lives in Dublin and works at Havok.\r\n",
    "country": "IRL",
    "first_name": "Stephen",
    "id": 24,
    "last_name": "Kelly",
    "state": "IE-L"
  },
  {
    "bio": "Sven has a long career in many markets and technologies. He has a keen interest in quality and passionate about Agile practices.  ",
    "country": "IRL",
    "first_name": "Sven",
    "id": 25,
    "last_name": "Rosvall",
    "state": "IE-L"
  },
  {
    "bio": "I only came to England to walk the Pennine Way\u2026 25 years later I still haven\u2019t done it. I did, though, get round to starting an AI company (spectacularly unsuccessful), joining another startup long before it was cool, learning C++, and spending a lot of time on trading floors building systems for complex derivatives. Sometimes hands on, sometimes managing people. Somewhere along the way I realised you can do cool stuff quickly in Python, and I\u2019ve never lost my fascination with making machines smarter.\r\n\r\nTwitter handle: @numericalresearch / @georgebernhard",
    "country": "GBR",
    "first_name": "Burkhard",
    "id": 27,
    "last_name": "Kloss",
    "state": "GB-ENG"
  },
  {
    "bio": "Greg is the co-founder and CEO of Undo. He is a coder at heart, but likes to bridge the gap between the\nbusiness and software worlds.\n\nGreg has 20 years\u2019 experience in the software industry and has held development and management roles at\ncompanies including the pioneering British computer firm Acorn, as well as fast-growing start ups, NexWave\nand Solarflare. It was at Acorn that Greg met Julian and on evenings and weekends, they invented the core\ntechnology that would eventually become UndoDB. Greg left Solarflare in 2012 to lead Undo as CEO and has\noverseen the company as it transitioned from the shed in his back garden to a scaling award-winning\nbusiness.\n",
    "country": "GBR",
    "first_name": "Greg",
    "id": 28,
    "last_name": "Law",
    "state": "GB-ENG"
  },
  {
    "bio": "Charles is a software developer at Bloomberg LP. He works in Developer\nExperience where he helps maintain and improve the tools used in\ndevelopment, and consult and advise on all aspects of software\ndevelopment.\n\nHis previous career in software has included roles in such diverse areas\nas web technology, business intelligence, data warehousing, defence and\nradar.\n\nHe understands the importance of optimal software practices and so has a\nkeen interest in source control systems and best practices surrounding\ntheir use.\n\nHe is a Git user, advocate and contributor and relishes the opportunity\nto slice through knotty problems with his git-fu and to teach others how\nto do the same.",
    "country": "GBR",
    "first_name": "Charles",
    "id": 29,
    "last_name": "Bailey",
    "state": "GB-ENG"
  },
  {
    "bio": "I help people express and present their ideas. Presentation Coach. Author of 'Presenting for Geeks' & 'Brainstorming Your Presentation'. Open Source enthusiast.",
    "country": "DEU",
    "first_name": "Dirk",
    "id": 30,
    "last_name": "Haun",
    "state": ""
  },
  {
    "bio": "After graduating in software engineering Pedro's interest in artificial intelligence led him to work in the\nvideo game industry for a year. That same interest has him now taking part of a Knowledge Transfer\nPartnership with Paxport(Multicom) and University of West of England working on a Machine Learning related\nproblem.\n",
    "country": "GBR",
    "first_name": "Pedro",
    "id": 31,
    "last_name": "Ferreira",
    "state": "GB-ENG"
  },
  {
    "bio": "Nicolai Josuttis (http://www.josuttis.com) is an independent systems architect,\ntechnical manager, author, and consultant. He designs mid-sized and\nlarge software systems for the telecommunication, traffic, finance, and\nmanufacturing industries.\nHe is well known in the C++ Community for speaking and writing with\nauthority about C++ (being the author of 'The C++ Standard Library' and\n'C++ Templates') but is also an innovative presenter.\nHe is an active member of C++ standardization committee for almost 20\nyears now.\n",
    "country": "DEU",
    "first_name": "Nicolai",
    "id": 32,
    "last_name": "Josuttis",
    "state": "DE-NI"
  },
  {
    "bio": "Games programmer since 1980, Guy Davidson has worked on the Total War franchise for Creative Assembly since 1999.\r\n\r\nHe contributes to the standard through SG14 and is interested in all aspects of making games and making good programmers into better programmers.",
    "country": "GBR",
    "first_name": "Guy ",
    "id": 33,
    "last_name": "Davidson ",
    "state": "GB-ENG"
  },
  {
    "bio": "Hubert Matthews has been programming in C++ for over 20 years and he has been teaching it for over 15 years. He also works as a systems architect and software consultant. Hubert has been a member of the UK BSI standards committee for C++. Hubert Matthews is a freelance consultant specialising in system architecture and design as well as training programmers in C++, UML, patterns and Java. His clients range from large companies and government to small companies and startups. Hubert lives in Oxford and in his abundant spare time he likes to pretend that he coaches rowing, dances salsa, dabbles with martial arts and drives too fast. ",
    "country": "GBR",
    "first_name": "Hubert",
    "id": 34,
    "last_name": "Matthews",
    "state": "GB-ENG"
  },
  {
    "bio": "Robert Smallshire is a founding director of Sixty North, a technology product and consulting business in Norway providing services throughout Europe. Robert has worked in senior software architecture and technical management roles in the energy sector, and is currently embarking on a new Internet-of-Things venture for solar power prediction and monitoring.\r\nHe has dealt with understanding, designing, advocating and implementing effective architectures for sophisticated scientific, enterprise and embedded software in Python, C++ and on the .NET stack. He holds a Ph.D. in a natural science.",
    "country": "NOR",
    "first_name": "Robert",
    "id": 35,
    "last_name": "Smallshire",
    "state": "NO-02"
  },
  {
    "bio": "Austin is a founding director of Sixty North, a software consulting, training, and application development company. A native of Texas, in 2008 Austin moved to Stavanger, Norway where he helped develop industry-leading oil reservoir modeling software in C++ and Python. Prior to that he worked at National Instruments developing LabVIEW, at Applied Research Labs (Univ. of Texas at Austin) developing sonar systems for the U.S. Navy, and at a number of telecommunications companies. He is an experienced presenter, teacher, and author, and he is an active member of the open source community. Austin is the founder of Stavanger Software Developers, one of the largest and most active social software groups in the Stavanger region. Austin holds a Master of Science in Computer Engineering from the University of Texas at Austin.",
    "country": "NOR",
    "first_name": "Austin",
    "id": 37,
    "last_name": "Bingham",
    "state": "NO-11"
  },
  {
    "bio": "Coordinator of ACCU Oxford group (https://www.meetup.com/ACCU-Oxford/) and ACCU Committee Member for ACCU\nLocal Groups (https://accu.org/index.php/accu_branches).\n",
    "country": "GBR",
    "first_name": "Nigel",
    "id": 38,
    "last_name": "Lester",
    "state": "GB-ENG"
  },
  {
    "bio": "Jez Higgins is a jobbing programmer so dedicated to the cause of software craftsmanship he once\ncycled to the conference from Birmingham.\n",
    "country": "GBR",
    "first_name": "Jez",
    "id": 39,
    "last_name": "Higgins",
    "state": "GB-ENG"
  },
  {
    "bio": "Phil is a Developer Advocate for C++, Objective-C and Swift tools at JetBrains. Prior to that he worked in as diverse fields as finance, agile coaching and iOS development. A long time C++ developer he also has his feet in C#, F#, Objective-C and Swift - as well as dabbling in other languages. He is the author of several open source projects - most notably Catch: a C++-native test framework.",
    "country": "GBR",
    "first_name": "Phil",
    "id": 40,
    "last_name": "Nash",
    "state": "GB-ENG"
  },
  {
    "bio": "Frank Birbacher is located in London and works as a software engineer at Bloomberg.  He studied computer science at RWTH Aachen University in Germany and worked as a software engineer at INFORM GmbH in Aachen.  Frank started programming with Basic and Assembler and had his first experience with C++ in 1998.  Lots of his knowledge of C++ was gained from Usenet where he was an active member of the group comp.lang.c++.moderated.  His main interest lies in the technical understanding of the language and its limits in theory and practice using different compilers on different platforms.\r\n\r\nDuring his studies Frank learned about functional programming and has been a fan of Haskell ever since.",
    "country": "GBR",
    "first_name": "Frank",
    "id": 41,
    "last_name": "Birbacher",
    "state": "GB-ENG"
  },
  {
    "bio": "I have been learning and using C++ for over a decade now, mostly developing and maintaining enterprise applications in the financial sector. I am self-taught, using books and online content as the primary resources for my learning. As an active member and moderator of a German C++ forum and later as a contributor on StackOverflow, I have used the \"learning by teaching\" approach to continue to learn and deepen my understanding of the language for several years. Since 2015 I write \"Simplify C++!\", a weekly blog about C++ and Clean Code (no, they do not contradict each other!).",
    "country": "DEU",
    "first_name": "Arne",
    "id": 42,
    "last_name": "Mertz",
    "state": "DE-HH"
  },
  {
    "bio": "Elliot is a software engineer working in London for Bloomberg LP, where he\nwrites libraries and tools to perform SQL-like operations on live financial\ndata.  He has a passion for library design and optimisations of all\nflavours.  Previously he has worked for other financial tech companies and\nas a freelance web developer.",
    "country": "GBR",
    "first_name": "Elliot",
    "id": 43,
    "last_name": "Goodrich",
    "state": "GB-ENG"
  },
  {
    "bio": "Prof. Peter Sommerlad is director of IFS Institute for Software at FHO/HSR Rapperswil, Switzerland. Peter is co-author of the books POSA Vol.1 and Security Patterns and contributed to \"97 things every programmer should know\". His goal is to make software simpler by Decremental Development: Refactoring software down to 10% its size with better architecture, testability and quality and functionality. To reach that goal his team and students created the C++ IDE Cevelop (based on Eclipse). Peter is a member of Hillside, ACM, IEEE Computer Society, SI, ACCU, and the ISO C++ standardization committee.\r\n",
    "country": "CHE",
    "first_name": "Peter",
    "id": 44,
    "last_name": "Sommerlad",
    "state": "CH-SG"
  },
  {
    "bio": "Kevlin is an independent consultant, speaker, writer and trainer. His development interests are in patterns, programming, practice and process. He has been a columnist for a number of magazines and sites and has been on far too many committees (it has been said that \"a committee is a cul-de-sac down which ideas are lured and then quietly strangled\"). He is co-author of A Pattern Language for Distributed Computing and On Patterns and Pattern Languages, two volumes in the Pattern-Oriented Software Architecture series. He is also editor of 97 Things Every Programmer Should Know. He lives in Bristol and online.",
    "country": "GBR",
    "first_name": "Kevlin",
    "id": 45,
    "last_name": "Henney",
    "state": "GB-ENG"
  },
  {
    "bio": "Sergey Ignatchenko has 20+ years of industry experience, and his first large system as a (co-)architect was a stock exchange  of a G20 country back in 1996. One of systems he architected is processing over 100 billion user transactions/year (and over 10 billion DB transactions/year). He's also known for his 30+ articles in industry journals (starting from articles in CUJ and C++ Report in 1998, and now writing for Overload on regular basis). Currently he's working on a book \"Development & Deployment of Multiplayer Online Games (from social games to MMOFPS, with stock exchanges in between)\", which has got well over 500 backers on Kickstarter. ",
    "country": "AUT",
    "first_name": "Sergey",
    "id": 46,
    "last_name": "Ignatchenko",
    "state": "AT-7"
  },
  {
    "bio": "Dietmar K\u00fchl is a senior software developer at Bloomberg L.P. working on the data distribution environment used both internally and by enterprise installations at clients. Before joining Bloomberg he has done mainly consulting for software projects in the finance area. He is a regular attendee of the ANSI/ISO C++ standards committee, presents at conferences, and he used to be a moderator of the newsgroup comp.lang.c++.moderated. He frequently answers questions on Stackoverflow.",
    "country": "GBR",
    "first_name": "Dietmar",
    "id": 47,
    "last_name": "K\u00fchl",
    "state": "GB-ENG"
  },
  {
    "bio": "Michel Grootjans has been programming since the age of 12. He has programmed strange machines like the TI 99-4A, the Atari 2600, Mac128, HP28, Apple II, Siemens PLC's using languages like Basic, Pascal, C, HyperTalk, Assembler, ... along the way.\r\n\r\nHis professional experiences includes building enterprise applications for government, chemical plants, telecom, HR, insurance companies, ... in Java, C#, Ruby and Javascript.\r\n\r\nHe's an independent technical agile coach. He coaches agile teams on continuous improvement, trying to find the most productive principles and practices to deliver value for the customer as fast as possible, while aiming for a product that is both flexible and maintainable.",
    "country": "BEL",
    "first_name": "Michel",
    "id": 48,
    "last_name": "Grootjans",
    "state": "BE-VLG"
  },
  {
    "bio": "Steve Love is a freelance software developer who has never written a compiler, but has written a (very small) operating system, of which he was once very proud. He now works on the periphery of the finance industry, writing C#, C++ and Python code when he can.",
    "country": "GBR",
    "first_name": "Steve",
    "id": 49,
    "last_name": "Love",
    "state": "GB-ENG"
  },
  {
    "bio": "Dominic has mis-spent the last 30 years and counting developing video games, flight simulators and software development tools in various assembly languages, C and C++. He founded and sold a video games company during the .com boom and is now a principal engineer at SN Systems, the subsidiary of Sony Interactive Entertainment that is responsible for the development tools for the Sony PlayStation platforms. He has spent the last 8 years developing a fault tolerant, distributed build accelerator in C++ in the style of Erlang.  He continues to cling to the hope that there are better ways of expressing concurrency in a manner more accessible to humans.\r\n",
    "country": "GBR",
    "first_name": "Dominic",
    "id": 50,
    "last_name": "Robinson",
    "state": "GB-ENG"
  },
  {
    "bio": "Worked for Intel and IBM, now working for Bloomberg",
    "country": "GBR",
    "first_name": "Sergey",
    "id": 51,
    "last_name": "Nepomnyachiy",
    "state": "GB-ENG"
  },
  {
    "bio": "Dom Davis is a veteran of The City and a casualty of The Financial Crisis. Not content with bringing the world to its knees he then went off to help break the internet before winding up in Norfolk where he messes about with development and devops. Dom is an enthusiastic and impassioned speaker [read: he gabbles] who uses a blend of irreverent sarcasm and flippant humour to bring complex subjects to a broad audience. Whether or not they understand him is up for debate, but he likes to believe they do.",
    "country": "GBR",
    "first_name": "Dom",
    "id": 52,
    "last_name": "Davis",
    "state": "GB-ENG"
  },
  {
    "bio": "J Daniel Garcia is an Associate Professor in Computer Architecture at University Carlos III of Madrid, Spain. He has been serving as head of the Spanish delegation to ISO C++ standards committee since 2008. Before joining academia he worked as a software engineer in industrial projects in different domains including real time control systems, civil engineering, medical imaging, aerospace engineering, and high performance scientific computing. He has lead the REPARA project funded by the European Commission and aiming refactoring C++ applications for parallel heterogeneous architectures. He also participates in the RePhrase European project related to better software engineering practices for parallel C++ applications. His main research goal is to make software developer lives easier by balancing software maintainability and application performance. In summary easier to read, faster to run, and less resources consumed.",
    "country": "ESP",
    "first_name": "J Daniel",
    "id": 55,
    "last_name": "Garcia",
    "state": "ES-MD"
  },
  {
    "bio": "OpenGL, Qt and C++ consultant, currently at KDAB. Mac / Apple aficionado, hacker of many rendering and visualisation engines, maintainer of open-source flight-simulator project 'FlightGear'.\r\n",
    "country": "GBR",
    "first_name": "James",
    "id": 56,
    "last_name": "Turner",
    "state": "GB-SCT"
  },
  {
    "bio": "Giuseppe is a Senior Software Engineer at KDAB, working on a number of C++ and QML projects, most of them requiring OpenGL knowledge. He is also a professional trainer, regularly delivering classes about Qt, C++ and OpenGL.\r\n\r\nGiuseppe is a long time contributor to Qt, having been using Qt since 2000, and an Approver in the Qt Project. His contributions to Qt range from containers and regular expressions to GUI and OpenGL. A Free Software passionate, he found his home in GNU/Linux systems.",
    "country": "GBR",
    "first_name": "Giuseppe",
    "id": 57,
    "last_name": "D'Angelo",
    "state": "GB-ENG"
  },
  {
    "bio": "Peter is a software engineer at ARM and Linaro, he has been working on software development tools for over\n16 years, specialising in non-compiler tools. He has been the maintainer of the ARM Compiler toolchain\nlinker armlink and is currently adding ARM support to the LLVM linker lld.\n",
    "country": "GBR",
    "first_name": "Peter",
    "id": 58,
    "last_name": "Smith",
    "state": "GB-ENG"
  },
  {
    "bio": "I have been working with C since 1984 or so and with {cpp} since 2005.  My current line of work at VMware is\nwriting debugging tools, including memory analyzers, deadlock analyzers and python extensions to gdb, and\nsometimes using these tools or offering advice on how to do so.\n",
    "country": "USA",
    "first_name": "Tim",
    "id": 60,
    "last_name": "Boddy",
    "state": "US-MA"
  },
  {
    "bio": "Marshall has been programming professionally for 35 years. He is the chair of the Library working group of the C++ standard committee. He is the lead developer for libc++, the C++ standard library for LLVM. He is the author of Boost.Algorithm, and has been a contributor to Boost for more than 15 years.\r\n\r\nHe works for Qualcomm in San Diego.",
    "country": "USA",
    "first_name": "Marshall",
    "id": 61,
    "last_name": "Clow",
    "state": "US-CA"
  },
  {
    "bio": "https://twitter.com/dmitrykandalov[Dmitry] has been programming and trying to get better at it since DOS\ntimes.  He is currently working with Java and JVM languages such as http://kotlinlang.org[Kotlin].  One of\nhis most recent programming endeavours is a re-implementation of https://github.com/dkandalov/kotlin-99[99\nprogramming problems in Kotlin].\n",
    "country": "GBR",
    "first_name": "Dmitry",
    "id": 62,
    "last_name": "Kandalov",
    "state": "GB-ENG"
  },
  {
    "bio": "Software engineer at Oracle. Working on NetBeans C/C++ project, mostly on code model part.",
    "country": "RUS",
    "first_name": "Petr",
    "id": 63,
    "last_name": "Kudriavtsev",
    "state": "RU-SPE"
  },
  {
    "bio": "Vladimir is a senior principal engineer in the Oracle Developer Studio \nteam, leading commercial Studio IDE and Open Source Netbeans C/C++ \nprojects. He is focusing on Parsing Technologies, Code Assistance, Refactorings support as well as Performance and Memory optimizations.",
    "country": "RUS",
    "first_name": "Vladimir",
    "id": 64,
    "last_name": "Voskresensky",
    "state": "RU-SPE"
  },
  {
    "bio": "Vittorio Romeo is a C++ enthusiast from a young age, now with a BS in Computer Science from the \"Universit\u00e0 degli Studi di Messina\". While following the evolution of the C++ standard and embracing the newest features, he worked on several open-source projects, including modern general-purpose libraries and free cross-platform indie games. Vittorio is an active member of the C++ community, speaking at many conferences and events. He currently maintains a YouTube channel featuring well-received modern C++11 and C++14 tutorials. When he's not writing code, Vittorio enjoys weightlifting and fitness-related activities, competitive/challenging computer gaming and good sci-fi movies/TV-series. ",
    "country": "GBR",
    "first_name": "Vittorio",
    "id": 65,
    "last_name": "Romeo",
    "state": "GB-ENG"
  },
  {
    "bio": "After spending 13 years developing applications for Czech Air Traffic Control, Jim bailed out in 2016 and landed in the world of DNS. He now spends his workdays coding while sitting between two DNS RFC authors. It's possible he might be learning something in the process.\r\n",
    "country": "GBR",
    "first_name": "Jim",
    "id": 67,
    "last_name": "Hague",
    "state": "GB-ENG"
  },
  {
    "bio": "Sergei has over 25-years experience as a programmer and architect. He started with simple programs for\nprogrammable calculators, and now works as Senior Software Architect at the Future Department of\nKaspersky Lab. Sergei has experience in various software development areas: high-load distributed software\nfor telecommunications and industrial sectors, instrumental libraries and frameworks, Web services and\napplications, database applications, development tools and others. Despite the many languages he has used in\npractice (Java, C#, Haskell, SQL, and so on), {cpp} is his primary and favourite language.\n",
    "country": "RUS",
    "first_name": "Sergei",
    "id": 69,
    "last_name": "Sadovnikov",
    "state": "RU-MOW"
  },
  {
    "bio": "My passions are robotics and software engineering and development. I developed software for many years in C\nand {cpp} in the Industrial, Robotics and AI fields.\n\nI was also a university (tenure track) professor and robotics researcher for 8 years. In 2012, I quit\nacademia to try to build a C/{cpp} dependency manager, co-founding a startup called biicode. Since then I\nhave been mostly developing software using Python.\n\nI am the https://www.conan.io/[Conan] C/{cpp} package manager co-creator and maintainer. This was recently\nacquired by JFrog. I am now working at JFrog as senior SW engineer and C/{cpp} advocate.\n",
    "country": "ESP",
    "first_name": "Diego",
    "id": 70,
    "last_name": "Rodriguez-Losada",
    "state": "ES-MD"
  },
  {
    "bio": "During his two and a half decades in the ICT industry, Ahto has worked in hardware installations and user support, as a software developer and architect, and as a systems analyst. Currently he is busy helping Guardtime's customers preserve the integrity of their important data. Outside his day job he coaches Estonia's team to the high school students' programming competitions. He has also been writing programming columns for the popular science magazines A&A and Horisont.",
    "country": "EST",
    "first_name": "Ahto",
    "id": 71,
    "last_name": "Truu",
    "state": "EE-78"
  },
  {
    "bio": "John Lakos, author of _Large Scale C++ Software Design_, serves at Bloomberg LP in New York City as a senior architect and mentor for C++ Software Development world-wide.  He is also an active voting member of the C++ Standards Committee\u2019s Evolution Working Group. Previously, Dr. Lakos directed the design and development of infrastructure libraries for proprietary analytic financial applications at Bear Stearns. For 12 years prior, Dr. Lakos developed large frameworks and advanced ICCAD applications at Mentor Graphics, for which he holds multiple software patents. His academic credentials include a Ph.D. in Computer Science ('97) and an Sc.D. in Electrical Engineering ('89) from Columbia University. Dr. Lakos received his undergraduate degrees from MIT in Mathematics ('82) and Computer Science ('81). His next book, entitled _Large-Scale C++, Volume I: Process and Architecture_, is anticipated in 2017.",
    "country": "USA",
    "first_name": "John",
    "id": 74,
    "last_name": "Lakos",
    "state": "US-NJ"
  },
  {
    "bio": "Mathias is a software engineer with a focus on C++ development, parallelism and performance, with experience in high-performance numerical computing and low-level systems programming.\r\n\r\nHe is currently working in finance on option market-making low-latency trading platform; but as a big aficionado of C++, he also likes to get involved with various open-source projects like Boost and the C++ standards committee of which he is a member since 2011.",
    "country": "GBR",
    "first_name": "Mathias",
    "id": 75,
    "last_name": "Gaunard",
    "state": "GB-ENG"
  },
  {
    "bio": "Bernhard Merkle works as a Software Architect and Engineer in the central Research & Development Department at SICK AG, one of the world\u2019s leading producers of sensors and sensor solutions. \r\nHe serves as internal consultant for the complete Software Development Cycle and is responsible for Process- and Methods-Selection as well as Tool-Evaluation and Introduction.\r\nIn his spare time he gives a lecture about Software Development. He writes technical articles and also gives sessions at various conferences (e.g. ACCU, Codegeneration, Conquest, QCon, OOPSLA, EclipseCon and OOP).  \r\n",
    "country": "GBR",
    "first_name": "Bernhard",
    "id": 76,
    "last_name": "Merkle",
    "state": "GB-ENG"
  },
  {
    "bio": "Arjan van Leeuwen is a developer at browser maker Opera Software, where he mainly works with C++. Reliability and speed are things that matter every day, but code quality is the subject that can really get him riled up. Arjan has worked on Opera Software's flagship product, the Opera browser for computers, for over 9 years and has spoken regularly at ACCU conferences.",
    "country": "FRA",
    "first_name": "Arjan",
    "id": 77,
    "last_name": "van Leeuwen",
    "state": "FR-U"
  },
  {
    "bio": "Timur is a developer passionate about C++, audio, music, and good code. He currently works at ROLI, where he develops JUCE, the leading cross-platform C++ framework for audio apps. Timur has previously given talks at CppCon, C++Now, and MeetingC++. He is also the program chair and co-organiser of the Audio Developer Conference (ADC), the annual gathering of the audio software developer community.",
    "country": "GBR",
    "first_name": "Timur",
    "id": 79,
    "last_name": "Doumler",
    "state": "GB-ENG"
  },
  {
    "bio": "Chris is a freelance programmer who started out as a bedroom coder in the 1980s writing assembler on 8-bit micros. These days it's enterprise grade technology in plush corporate offices. He also commentates on the Godmanchester duck race and can be easily distracted via gort@cix.co.uk or @chrisoldwood.",
    "country": "GBR",
    "first_name": "Chris",
    "id": 80,
    "last_name": "Oldwood",
    "state": "GB-ENG"
  },
  {
    "bio": "Jason is a contract programmer in C++ on Linux. With over 15 years experience, including programming prototype super-computers, but mainly in finance, now focussing on low-latency and HFT software, their architectures and the issues arising from them. I am also actively involved with the UK C++ Panel and the ACCU to maintain my skill-set.",
    "country": "GBR",
    "first_name": "Jason",
    "id": 81,
    "last_name": "McGuiness",
    "state": "GB-ENG"
  },
  {
    "bio": "Peter Hilton is a software developer, writer, speaker, trainer, and musician. Peter\u2019s professional interests are business process management, web application development, functional design, agile software development and documentation. Peter currently works as a programmer and technical writer for Signavio, working remotely from Rotterdam, and delivers the occasional lecture and training course.\r\n\r\nPeter\u2019s software development interests include web applications, service architecture, software development methodology and practices, and web-based collaboration. Peter has presented at several European developer conferences, including ACCU, Scala eXchange, Devoxx, \u00d8redev, Jfokus, Javazone, geecon and TopConf. Peter co-authored \u2018Play for Scala\u2019 (Manning Publications) and has taught \u2018Fast Track to Play with Scala\u2019.",
    "country": "NLD",
    "first_name": "Peter",
    "id": 82,
    "last_name": "Hilton",
    "state": "NL-ZH"
  },
  {
    "bio": "Anthony Williams is the author of C++ Concurrency in Action, and a UK-based developer and consultant with many years of experience in C++. He has been an active member of the BSI C++ Standards Panel since 2001, and is author or coauthor of many of the C++ Standards Committee papers that led up to the inclusion of the thread library in the C++11 Standard. He is the developer of the just::thread implementation of the C++11 thread library from Just Software Solutions Ltd. Anthony lives in the far west of Cornwall, England.",
    "country": "GBR",
    "first_name": "Anthony",
    "id": 86,
    "last_name": "Williams",
    "state": "GB-ENG"
  },
  {
    "bio": "Alfred started the IncludeOS project as a part of his ongoing PhD work aimed at improving resource efficiency in cloud computing. He's been employed since 2011 as Assistant Professor at Oslo and Akershus University College of Applied Science, the largest institution for engineering education in Norway, where among other things he taught C++ for 5 years. Alfred is currently working full time on IncludeOS through a startup spun out of the college and funded in part by the Norwegian Research Council. Alfred has 10+ years industrial programming experience. He holds an MSc. in Mathematical Logic and BSc in computer science from the University of Oslo. \n",
    "country": "NOR",
    "first_name": "Alfred",
    "id": 89,
    "last_name": "Bratterud",
    "state": "NO-03"
  }
    ],
    "scheduled_proposals": [
  {
    "day": "day_4",
    "id": 4,
    "presenters": [
      3
    ],
    "room": "empire",
    "session": "session_1",
    "text": "Are you using enums to return error states from functions (or even an int or bool!)? Do you find writing exception safe C++ a poor return on coding investment, and end up avoiding using most of the STL entirely because it could throw exceptions in all sorts of unhelpful places? Have you ever wondered what on earth the C++ 11\u2019s <system_error> header is actually useful for?\n\nOne might think that after thirty years C++ would have decided upon a canonical way of handling errors, but it is very clear the jury remains out with heavy fragmentation in the C++ user base as to how best to handle errors. The new systems programming languages Rust and Swift have chosen a canonical error handling system based on immediate stack unwinding returns of integer error codes in a monadic wrapper e.g. Rust\u2019s Result<T> and Option<T>. Efforts are underway to standardise something similar for C++ with optional<T> and soon WG21 LEWG\u2019s expected<T, E> which recently lost its monadic operations as it gets pared ever further down to its essentials for standardisation.\n\nThis talk reviews these four standardised error handling techniques in C++, and how well the three major compilers and library implementations implement these techniques into overhead. I will also be introducing for the first time my own solution to this problem called _outcomes_ (implemented by a proposed Boost.Outcome library) which implement a very impure and dirty - but very lightweight on compile and runtime overhead \u2013 simple \u201cmongrel monad\u201d outcome<T>, result<T> and option<T> transport factory specifically targeted at extending C++ 11\u2019s std::exception_ptr and std::error_code in a more convenient to use form, thus providing a unified lossless error handling system for C++. I am hoping these will eventually form part of SG14 (games/low latency)\u2019s recommendations for maximum performance C++ as a lighter weight and more convenient to use for error handling alternative to the LEWG expected<T, E>.\n\n",
    "title": "Mongrel Monads, Dirty, Dirty, Dirty"
  },
  {
    "day": "day_1",
    "id": 5,
    "presenters": [
      4
    ],
    "room": "bristol_2",
    "session": "session_3",
    "text": "In most languages, metaprogramming is a powerful tool that allows writing more expressive and more maintainable code. It is usually relatively straightforward, and even average Joe programmers can use it to increase their productivity. In C++, metaprogramming is an obscure art that very few understand and that is never taught as part of the normal curriculum. Even worse is the fact that almost every presentation about metaprogramming is overly complicated, using tricky corners of the language and an unintuitive approach to achieve even simple goals. This presentation will try to break the mold and present metaprogramming in a way that's easy to grasp. Using C++14 and the Boost.Hana library, we will show how metaprogramming can be done with a reasonably high level of expressiveness, leaving dirty template tricks far behind. We will see how metaprogramming can be used as a tool for making day-to-day programming easier, more enjoyable and more efficient, even for people that are not C++ gurus.",
    "title": "Metaprogramming in C++14"
  },
  {
    "day": "day_4",
    "id": 6,
    "presenters": [
      5
    ],
    "room": "great_britain",
    "session": "session_1",
    "text": "Behaviour Driven Development is an agile development technique that improves collaboration between technical and non-\u00adtechnial members of the team, by exploring the problem using examples. These examples then get turned into executable specifications, often called \u2018scenarios\u2019. The scenarios should be easy to read by all team members, but writing them expressively is harder than it looks!\n\nIn this 90 minute workshop you will learn how to write expressive BDD scenarios. We\u2019ll start by giving you a *very* brief introduction to BDD. You\u2019ll then be introduced to different writing styles by reviewing pre\u00adprepared scenarios. If there's still time, you\u2019ll get a chance to write your own scenarios based on examples that we\u2019ll bring along.\n\nWe\u2019ll be using Gherkin, the syntax used by Cucumber and SpecFlow \u00ad but you won\u2019t need a computer.\n",
    "title": "Writing good BDD scenarios"
  },
  {
    "day": "day_3",
    "id": 9,
    "presenters": [
      5
    ],
    "quickie_slot": "slot_3",
    "room": "bristol_3",
    "session": "session_1",
    "text": "Test Driven Development (TDD) and Behaviour Driven Development (BDD) are very similar.\n\nI'll explain why the most important part of both acronyms is the first 'D' for Driven and why it would be better if the second 'D' stood for Design.\n\nWe'll explore what challenges you might face when trying to adopt this way of working and what benefits you will reap when you succeed.",
    "title": "Intro to TDD and BDD"
  },
  {
    "day": "day_3",
    "id": 11,
    "presenters": [
      6
    ],
    "room": "bristol_2",
    "session": "session_2",
    "text": "A popular technique in unit testing is to break dependencies by\nreplacing collaborators of the unit under test with mock\nobjects. Mocking frameworks makes it easier to create mock objects.\n\nTrompeloeil is a new, open source, mocking framework written in C++14. It is easy to use while also allowing great expressive power.\n\nThis presentation will show how to use Trompeloeil by following the step-by-step development of an example program using TDD (test driven development.) The example will begin with the most basic usage and go on to cover increasingly more advanced topics, including:\n\n* testing patterns\n* techniques for controlling sequential ordering relations\n* how to represent data in violation messages\n* managing the life time of mock objects\n* writing matchers\n* disambiguating overloads\n\nThe presentation will also include call outs for participation to help further the development.\n\nLevel: intermediate->advanced",
    "title": "Using Trompeloeil, a mocking framework for modern C++"
  },
  {
    "day": "day_1",
    "id": 14,
    "presenters": [
      9
    ],
    "room": "great_britain",
    "session": "session_2",
    "text": "I'm a developer and I get frustrated when things are harder than they should be. Our product (Mir) was harder to release and to use than it should be but no-one cared enough to do anything about it.\n\nMy employer allows time for (approved) \"side projects\". Exploiting this, I started writing an \"Abstraction Layer\" (MirAL) as a proof-of-concept that these problems could be solved.\n\nOver time it became apparent that this approach solved other problems and management interest grew. Until MirAL became my \"day job\" and adopted as part of the product.\n\nThis talk covers the both the technical and organisational aspects of the problem and the solution. Hopefully, comparisons can be made with the experience of attendees.",
    "title": "The MirAL Story"
  },
  {
    "day": "day_3",
    "id": 15,
    "presenters": [
      10
    ],
    "room": "great_britain",
    "session": "session_2",
    "text": "Since the introduction of the Bitcoin crypto currency by Satoshi Nakamoto in 2008, there has been an explosion of interest in the adoption and use of blockchain, the fundamental technology underlying Bitcoin (and its many variants). At Mosaic Financial Markets we have been researching ways of understanding and applying blockchain technology, focussing primarily (but not exclusively) on the Ethereum blockchain, as Ethereum offers a fully programmable 'smart contract' capability. \n\nThere is an enormous amount of interest (and hype) surrounding blockchains - we will explain what we have discovered, cut though some of the hype, and we hope give you some suggestions for working with this technology. \n\nWe have found that to successfully build blockchain applications, we needed to change the way we were thinking about the application architecture, understanding the benefits and costs of using a globally distributed, trustless, resilient and immutable transaction record.  \n\nThis session will give you an overview of the fundamental concepts behind blockchains, including Bitcoin and its variants, Ethereum, R3's Corda and other platforms under development. We will explain how we have lived with a rapidly-evolving platform which has undergone significant disruptive events, including the (in)famous 'DAO hack'. We have built three proof-of-concept Ethereum applications to help us understand what does and doesn't work, and we will show you how and why we built them. \n",
    "title": "Introduction to Blockchain technology, and how to build something useful with it"
  },
  {
    "day": "day_1",
    "id": 18,
    "presenters": [
      14
    ],
    "room": "empire",
    "session": "session_3",
    "text": "It sounds too difficult for mere mortals, but in principle a programming language interpreter is a relatively simple program.  To demonstrate the main ideas involved, I wrote a very simple programming language called Cell (github.com/andybalaam/cell) and in this session we will walk through how it works.\n\nCell's interpreter is written in Python, and the Cell language itself is designed to be as simple as possible to implement.  This leads to some different trade-offs from most other languages, but hopefully leaves the main concepts intact.\n\nWe will walk through the code of Cell's lexer (40 lines), parser (81 lines) and evaluator (92 lines) and on the way cover the main ideas you need to write your own language, including detecting the different symbols and literals the programmer wrote, building them up into a tree structure, evaluating the logic that is being represented, and writing a standard library of basic functions and structures.\n\nThis session is suitable for someone who has never thought of writing a programming language before.  We will assume a working knowledge of Python code in places, but it should be simple enough to follow for anyone who regularly writes code in any language.",
    "title": "How to write a programming language"
  },
  {
    "day": "day_1",
    "id": 19,
    "presenters": [
      15
    ],
    "room": "bristol_3",
    "session": "session_2",
    "text": "Modern development environments and debuggers enable us to spend much of our time writing and reading source code.\nThis makes the life of a developer much easier and most of the time we can reason about our program solely based on the source code itself.\n\nHowever, from time to time we need to understand the layers beneath our high level language; for example when debugging a program or a crash.\n\nWhat sense can we make of a page of assembly language code - and how do we find the most important information easily?\n\nI'll look at some typical use cases, mainly focussing on 64-bit C++ programs as these are relatively \"close to the metal\".\n\n- What instructions are most common, and roughly what do they correspond to?\n- How do I walk the stack to find my caller(s)?\n- Where are my variables hiding?\n\nThe intent is to help you in relating the assembly language view of a program to the lines of source code.\n\n(No prior knowledge of assembler is required.)",
    "title": "Bluff your way in x64 assembler"
  },
  {
    "day": "day_4",
    "id": 21,
    "presenters": [
      15
    ],
    "room": "bristol_1",
    "session": "session_2",
    "text": "Your chance to put questions to a selection of members of the ISO C++ committee. Here are a few ideas:\n\n* What's in the next standard?\n* What's the best (and worst) thing about standard C++?\n* How can I get involved in the process?\n",
    "title": "Grill the C++ committee"
  },
  {
    "day": "day_3",
    "id": 22,
    "presenters": [
      16
    ],
    "room": "empire",
    "session": "session_3",
    "text": "We often use the metaphor of smell to describe issues with code which haven't necessarily manifested, but could end up causing serious problems (\u201ccode smells\u201d).\n\nArchitectural and habitability smells can help guide us during low-level debugging. The goal of this session is to give participants the tools they need to help refine their own and others\u2019 sense of code smell further.\n\nParallels will be drawn between techniques for refining actual sense of smell and improving debugging techniques.\n\nFirst 40 minutes - theoretical overview\n\n- The difficulties of low-level, real-time debugging, including different types of trace and their advantages and disadvantages\n- Testing - where it works, where it\u2019s hard, and where it\u2019s impossible\n- Habitability and how it relates to bugs\n- Overview of lots of different \u201ccode smells\", all with real world, embedded examples\n\nNext 40 minutes - mob programming practical\n\nFun, real-world problem with a custom threading implementation. There will be no libraries involved here - a complete (albeit small) scheduler / RTOS will be provided that isn\u2019t quite working correctly.\n\nThe group will be split into \u201cmob teams\u201d of 4-5 people and set up next to a large monitor each (which I will provide) so they can \"mob program\u201d together in order to solve the problem. Mob programming is a relatively new Agile technique which we regularly use to solve difficult problems. Each person in the team takes in turns to \u201cdrive\u201d at the keyboard.\n\nThere will be prizes for the winning team.",
    "title": "Improving Sense of Smell for Low-Level Debugging"
  },
  {
    "day": "day_3",
    "id": 23,
    "presenters": [
      17
    ],
    "room": "empire",
    "session": "session_2",
    "text": "It is unusual to find software which does not have to perform I/O of some kind, be it talking to persistent storage devices or communicating between networked machines. These operations are typically categorised by the fact that they incur latency - time which your software must wait patiently before it can continue its work. In a world ever reliant on distributed computing, with trends such as \"cloud\" and \"micro-services\", this concern has never been more prevalent. Developing software which is correct and resource efficient is not an easy task at the best of times, so involving slow networks and flaky spindles of rust will not make our life easier. Software which is heavily reliant on I/O is often complex in nature, as we encounter a number of trade-offs to achieve the perfect balance of efficiency, correctness and maintainability.\n\nIs there finally light at the end of the tunnel? Patterns are now gaining acceptance in younger languages which are gaining a broad, cross-language acceptance not often seen. This talk will take a brief look at the history of writing I/O centric software, and the techniques employed over time. By understanding these and the reason for each evolution, we can be better equipped to write, test and debug asynchronous software. Whilst C and C++ will serve as a basis for most of the talk, emphasis will also be placed on language independent concepts where appropriate.\n\nTopics to be covered will include:\n\n* Why I/O is hard - the trade-offs\n** Efficiency, performance, utilisation\n** Correctness, reasoning, safety, testability\n* The baseline - blocking I/O\n* Forking and threading\n* Select and poll\n* Epoll et al - \u201cC10K\u201d\n* Callback based libraries (e.g. ASIO)\n* Why std::future is not the future for I/O\n* Coroutines - are we there yet?\n\nGiven time, the talk will briefly summarise techniques which have been employed in other languages, are not trivially available, or have lacked wide adoption in C/C++, such as: communicating sequential processes (Occam, Go), user-space (green) threads, task-stealing. We may discover that through all the techniques discussed, there is a lot more in common between them than is obvious at first glance.",
    "title": "History of Time: Asynchronous C++"
  },
  {
    "day": "day_1",
    "id": 24,
    "presenters": [
      18
    ],
    "room": "bristol_1",
    "session": "session_3",
    "text": "With its history going back to the early days of programming, rich heritage, tons of legacy code mixed with modern language features and patterns, quickly evolving language standards, and a variety of tools in the environment, C++ can be tricky and easily enable hacks and inaccurate solutions if you don\u2019t cook it right.\n\nDeveloping language tools (and IDEs in particular) is a good litmus test for such problems. When a tool gets confused by some code or fails to provide the full intelligence it\u2019s supposed to possess, doesn\u2019t that mean that developers should also pay more attention and be more careful in the same situations? This talk is dedicated to bringing such situations to light and sharing lessons learned.\n\nWe\u2019ll cover core language trickiness and peculiarities, including preprocessor and context-dependent parsing, and how the modern language standards can be helpful.\n\nWe\u2019ll also look at some good practices that can help prevent shooting yourself in the leg with C++, and will reflect on C++ Code Guidelines.\n\nWe\u2019ll analyze the tooling heritage as well, looking at the variety of build systems, compilers, debuggers, unit testing frameworks and package managers. Understanding the drawbacks of how they are integrated into language tools will give us insight into their limitations as well as into more accurate and error-free development in C++.",
    "title": "A look at C++ through the glasses of a language tool"
  },
  {
    "day": "day_4",
    "id": 25,
    "presenters": [
      19
    ],
    "room": "bristol_1",
    "session": "session_3",
    "text": "Many of the concepts presented in Andrei Alexandrescu's book \"Modern C++ Design\" were arguably ahead of their time. Many of the concepts could not be effectively or cleanly expressed due to a lack of language features and the user was often exposed to too much complexity.\n \nNow 15 years later we have many more tools. Now Alexandrescu's as well as similar statically linking yet powerful and generic design patterns are proving invaluable in resource constrained and low latency fields.\n\nIn this talk I will share my experience creating \"post modern\" C++ abstractions for bare metal hard realtime systems as well as my work on the tools needed to provide sleek and sexy public interfaces for these libraries such as various improvements to template metaprogramming libraries, lazy evaluation techniques and named parameters. \n\nI hope to add idioms and design patterns to any advanced programmers toolbox allowing them to more efficiently and more effectively abstract whatever domain they work in.\n",
    "title": "Modern C++ Design reloaded"
  },
  {
    "day": "day_3",
    "id": 26,
    "presenters": [
      19
    ],
    "quickie_slot": "slot_1",
    "room": "great_britain",
    "session": "session_1",
    "text": "The only boost.parameter library was seldom used, mainly because it is macro hell getting it working, its not SFINAE friendly and the return type of a function cannot depend on the types of the inputs. \nWith modern C++ we can solve all those problems elegantly. This works especially well when making factory functions which spit out policy based class specializations.",
    "title": "Named parameters"
  },
  {
    "day": "day_1",
    "id": 28,
    "presenters": [
      20
    ],
    "room": "bristol_3",
    "session": "session_3",
    "text": "Recent European financial regulations have required \"traceable time\". The ability to prove the correctness of you timestamps relative to a defined reference such as UTC. The first such requirement within civilian industries.\n\nIn this talk, we will take a look at the regulations and why they are challenging. We will define some words with which we can describe time readings, look at how time arrives at our machines, how we trace it, and how std::chrono and in fact all current programming languages lets us down. \n\nWe will then look into the future and see how the hard to do will become increasingly harder; we'll suggest why this is not just for the banks and hedge funds, how provably accurate wall clock time is going to be increasingly important in a connected, heterogeneous world.\n\nFinally, we will have a look at what we can to rectify these shortcomings and propose some ideas around abstract APIs and possible underlying implementation options. This latter part of the session, in particular, will seek thoughts and comments from the audience on architecture specific constraints/solutions.\n\nThis talk should be easily accessible to all levels, though an interest in how computers measure time will be useful.\n\nThose in Banking/Finance and also high-performance distributed (grid/cloud) computing will find direct relevance. Internet of Things, self-driving cars, and multimedia broadcasting should also find relevance.",
    "title": "Time gentlemen please"
  },
  {
    "day": "day_1",
    "id": 29,
    "presenters": [
      21,
      22
    ],
    "room": "great_britain",
    "session": "session_3",
    "text": "This is a fun session based on the popular UK game show _Countdown_ [1] and its parody, _8 out of 10 cats\ndoes Countdown_ [2].\n\n* In the TV version contestants take turns picking 9 random vowels/consonants and finding the longest word\nin 30 seconds.\n* in this version contestants take turns picking 7 random {cpp} tokens from 5 categories: (keywords,\nidentifiers, operators, punctuators, literals) and writing the _shortest_ {cpp} program using _all_ 7 tokens\nin 8 minutes.\n\nFor example, if these 7 tokens are selected:\n\n[source,cpp]\n----\nconst vector tokens =\n{\n    \"catch\",              // keyword\n    \"->\",                 // operator\n    \"[\",                  // punctuator\n    \";\",                  // punctuator\n    \"--\",                 // operator\n    \"foobar\",             // identifier\n    \"operator\",           // keyword\n};\n----\n\nThen a winning program (53 characters long) might be:\n\n[source,cpp]\n----\nclass c {\n  c operator->(){\n    foobar:\n    try{\n    }\n    catch(c x[]){\n        x--;\n    }\n  }\n};\n----\n* Programs will be written in customized cyber-dojo [3] sessions which\nautomatically checks which tokens have been missed and tells you\nthe program's size.\n* Numbers are limited: minimum two people per team, maximum 12 teams.\n* Once it is full, you can still be part of the audience, and \"play along at\nhome\".\n* _Bring your laptop!_\n\n\n[1] http://www.channel4.com/programmes/countdown\n\n[2] http://www.channel4.com/programmes/8-out-of-10-cats-does-countdown\n\n[3] http://cyber-dojo.org\n",
    "title": "ACCU does C++ Countdown"
  },
  {
    "day": "day_2",
    "id": 31,
    "presenters": [
      24
    ],
    "room": "great_britain",
    "session": "session_3",
    "text": "Because CMake is already over 15 years old, best practices have changed over time, in particular in the last 4 years. This talk will explore how to achieve some tasks using modern CMake idioms, as well as tooling and future directions.\n\nC and C++ developers wishing to build code on multiple platforms will often rely on CMake to find dependencies and generate their build system.\n\nThe Internet is full of ways to write CMake code as it was common in 2006. However, CMake itself has moved on. A new set of APIs introduced in more-recent CMake versions aim for a conceptual consistency, simplicity and modularity in CMake code which was not previously possible.\n\nCMake backward compatibility promises ensure that existing code continues to work, but as for C++, this form of \u2018Modern CMake\u2019 aims to simplify the developer experience, result in easier, more understandable and maintainable code, and establish future direction for how we use CMake.\n\nThis presentation will illustrate some differences and advantages between legacy approaches to CMake code and \u2018Modern CMake\u2019. After this presentation, the audience will be able to easily recognize legacy code and be able to make refactoring steps to improve the build system code.",
    "title": "Embracing Modern CMake"
  },
  {
    "day": "day_4",
    "id": 32,
    "presenters": [
      25
    ],
    "room": "bristol_3",
    "session": "session_3",
    "text": "Collective Code Ownership is a tenet in most Agile methodologies and many Agile books suggest enforcing this with Pair Programming. Collective Code Ownership can also be upheld through Code Reviews. Formal code reviews can be very costly and destructive. They are hard to implement correctly but when done right they can provide many benefits such as finding bugs and sharing knowledge about designs and code base within the team. This talk looks at how to perform effective code reviews with little effort using code review tools to achieve the same benefits as formal reviews. I will share experiences with code review tools and compare a few available tools.\n",
    "title": "Practical Code Review using tools"
  },
  {
    "day": "day_3",
    "id": 35,
    "presenters": [
      27
    ],
    "room": "bristol_3",
    "session": "session_3",
    "text": "As Uncle Bob pointed out, software is everywhere, and without software, nothing works.\n\nThat gives us great power, and \u2013 as we all know \u2013 with great power comes great responsibility.\n\nWe have to make choices every day that affect others, sometimes in subtle and non-intuitive ways. To mention just a few:\n\n* What logs should we capture? How does that change if we have to hand them over to the government?\n* Are our hiring practices fair? Are we sure about that? \n* Is there bias in our algorithms that unfairly disadvantages some groups of people?\n* Is the core function of our software ethical? How about if it's deliberately misused?\n\nI hope to raise a few of these questions, not to provide answers \u2013 I don't have any \u2013 but to stimulate debate.",
    "title": "The Ethics of Software - some practical considerations"
  },
  {
    "day": "day_2",
    "id": 36,
    "presenters": [
      28
    ],
    "room": "empire",
    "session": "session_1",
    "text": "Many programmers aspire to start a company. It's less often about getting rich as it is to pursue a vision\nfor a computer program(s) that is much bigger than one person could do alone. Like most programmers who\nstart up, I had no formal training and little experience outside of software development. I was naively\nconfident, and didn't know what I didn't know (it turned out that that was a LOT!) In this talk I'll present\nsome of the lessons I've learned along the way, many of which were a complete surprise to me. I'll cover\ngetting investment, building the product, building a team, and getting and keeping customers. Little of this\ntalk is directly about programming, but it is aimed at programmers who want to create code in order to\ncreate a business, or who want to create a business so that they can create the code they want. This talk\ncontains candid, warts-and-all war-stories, and because it's for programmers, comes with a no adverts and no\nbusiness-talk BS guarantee. Some of the content of this talk is also useful to programmers who are moving\ninto management or customer-facing roles.\n",
    "title": "The Programmer CEO, and how to do a software startup"
  },
  {
    "day": "day_3",
    "id": 37,
    "presenters": [
      28
    ],
    "quickie_slot": "slot_4",
    "room": "empire",
    "session": "session_1",
    "text": "Test Driven Development, Continuous Integration (CI), and testing with elastic compute in the cloud mean that a typical software project today will run 1000s of times more tests every hour than an equivalent sized project would have run ten years ago. This is undeniably a huge advance on previous best practices, but it does bring with it a new challenge: how to triage and manage all of the test failures? This talk will investigate the implications of this challenge and shall examine techniques and technologies that can overcome it. Only then can CI finally deliver on its promise.",
    "title": "The missing piece of the continuous integration puzzle - what to do with all those test failures?"
  },
  {
    "day": "day_3",
    "id": 39,
    "presenters": [
      29
    ],
    "room": "bristol_3",
    "session": "session_2",
    "text": "The index has been a core part of Git since its inception and yet its existence and purpose are often stumbling blocks for newcomers to Git. Even people experienced with Git often struggle to separate its interface from its implementation details.\n\nThis talk aims to improve understanding of the index and to show how to take advantage of its power.\n\nFirst, we'll examine the history of Git's index - effectively the first feature ever added to Git - to help explain why the index is the way it is. I shall look at the background and rationale behind some of the other words used for index: \"cache\" and \"staging area\".\n\nNext, I want to examine the features of the index as it exists in Git today and to separate exactly what I think that all Git users need to understand from the benefits that the index brings to Git's implementation which aren't necessary for a Git beginner to be aware of.\n\nFinally, I'll demonstrate some index manipulation tips and trips that have practical use. These will include a look at cases where the plumbing commands such as read-tree, update-index and checkout-index can be usefully employed, use of an alternate index by defining GIT_INDEX_FILE and the performance benefits of filter-branch's --index-filter over more mundane alternatives.",
    "title": "Mastering Git's index"
  },
  {
    "day": "day_3",
    "id": 40,
    "presenters": [
      30
    ],
    "quickie_slot": "slot_2",
    "room": "empire",
    "session": "session_1",
    "text": "Job ads often ask for creativity as one of the skills for software developers. But what does creativity in software development actually mean? And how can you be creative under pressure?\n\nThis talk introduces a simple method to help you trigger your creativity when under stress.",
    "title": "Requirement: Creativity"
  },
  {
    "day": "day_4",
    "id": 41,
    "presenters": [
      30
    ],
    "room": "bristol_3",
    "session": "session_2",
    "text": "Presentations in meetings have a tendency to be long-winding, telling you things you already know, things you don't need to know, and things you don't need to know yet. The things you actually need to know are in there, too; somewhere. But it's hard to find them.\n\nWouldn't it be great if business presentations were more focussed on the actual needs of their audience? And if they would only take 15 minutes, including the time for Q&A? Not possible? Well, presentation expert Joey Asher promises that it is possible. We'll take a look at his approach and maybe you'll only be giving 15-minute presentations from now on, too.\n\nNote: This session is not a workshop but does have some interactive elements.",
    "title": "How to present effectively in a meeting"
  },
  {
    "day": "day_3",
    "id": 42,
    "presenters": [
      11,
      31
    ],
    "quickie_slot": "slot_3",
    "room": "great_britain",
    "session": "session_1",
    "text": "This presentation is a case study taken from the travel and holiday industry. Paxport/Multicom, based in UK\nand Sweden, have recently adopted a recommendation system for holiday accommodation bookings. Machine\nlearning techniques such as Collaborative Filtering have been applied using Python (3.5.1), with Jupyter\n(4.0.6) as the main framework. Data scale and sparsity present significant challenges in the case study, and\nso the effectiveness of various techniques are described as well as the performance of Python-based\nlibraries such as Python Data Analysis Library (Pandas), and Scikit-learn (built on NumPy, SciPy and\nmatplotlib). The presentation is suitable for all levels of programmers.\n",
    "title": "Machine Learning with Python Case Study"
  },
  {
    "day": "day_1",
    "id": 48,
    "presenters": [
      32
    ],
    "room": "great_britain",
    "session": "session_1",
    "text": "Assume, we implement a very simple class having a string as member.\n\nAs an ordinary Application Programmer:\n\n* How should it be used?\n* How should it be implemented?\n\nEven if you want to have the best performance!\n\nYou think you know the answer?\nWell, you might be wrong!\n\nLet's look at a simple class with a string member and see the effect using different implementation approaches (using constructors passing by value, by reference, or doing more sophisticated tricks).\n\nSooner than later we will fall into the deep darkness of universal references and enable if...",
    "title": "The nightmare of Move Semantics for Simple Classes"
  },
  {
    "day": "day_3",
    "id": 49,
    "presenters": [
      22
    ],
    "quickie_slot": "slot_2",
    "room": "bristol_3",
    "session": "session_1",
    "text": "In the 2016 conference I did a 90 minute talk on the design and evolution of cyber-dojo. In this talk I provide an update on its further evolution, talking about (but not limited to) its\n\n* further decoupling using micro-services\n* multi-stage Travis build pipeline\n* pros and cons of 100% coverage\n* selenium testing hosted in a docker image\n* Ruby custom mini-testing-framework\n* decision to abandon versioning\n* testing the micro-services using a dual client-server approach\n\nhttp://cyber-dojo.org is an open-source web-based application for hosting team-based coding dojos. \n",
    "title": "Design and Evolution of cyber-dojo"
  },
  {
    "day": "day_2",
    "id": 50,
    "presenters": [
      33
    ],
    "room": "bristol_1",
    "session": "session_1",
    "text": "The SG13 subgroup, HMI or Human-Machine Interface, seeks to offer a 2D graphics API to the standard\ncommittee. This is a considerable improvement on _stdout_ when it comes to output from programs.\n\nOne advantage such an API offers is a standard platform for game development: currently, one has to choose\nfrom a considerable array of libraries and engines such as OpenGL, DirectX, SDL, SFML, and so on. The job of\nmerely creating and displaying a window is deeply non-trivial.\n\nThis talk will consider the prospect of developing games using only standard {cpp}. It will cover the\noptions available for the single developer learning to write games, and how this may change with the\nadoption of this new API. It will include plenty of simple examples and consider how this might change how\n{cpp} is taught and how this increases accessibility to school-age learners.\n\nWe will also write a game together. Live.\n",
    "title": "Writing games in very modern C++"
  },
  {
    "day": "day_2",
    "id": 51,
    "presenters": [
      34
    ],
    "room": "bristol_2",
    "session": "session_3",
    "text": "C++ programmers want fast and small code that is safe, generic and reusable. This talk shows how using the C++ type system and templates can achieve this using simple lightweight abstractions.\n\nType-rich APIs help avoid errors whilst improving readability, and template techniques provide reusable libraries for operators and their relationships with zero run-time overhead.",
    "title": "The C++ Type System Is Your Friend"
  },
  {
    "day": "day_2",
    "id": 52,
    "presenters": [
      35
    ],
    "room": "bristol_3",
    "session": "session_2",
    "text": "Wireless sensors networks are a central feature of the Internet of Things. Unfortunately, many useful sensors are proprietary designs which use undocumented wireless protocols, locking our data into the vendor\u2019s devices or services. The closed nature of these protocols inhibits interoperability of these devices within larger systems, and might even be considered ethically dubious.\n\nI will tell the story of a small-scale, industrial reverse engineering effort to liberate our data from a proprietary solar irradiance meter which transmits measurements over a wireless link to an equally proprietary remote base-station.  By combining protocol analysers developed in Python and Excel with a logic analyser, oscilloscope and a large measure of obstinate tenacity, we illustrate how the signal protocol was ultimately figured out. This information was used to inform an open-source protocol implementation in C++, designed to run on a simple open-source hardware device comprising an 8-bit microcontroller and a radio receiver connected to a Raspberry Pi.\n\nCuriously, the forensic process revealed several design flaws in the upstream proprietary sensor software, one of which results in silent correctness failures of the system, calling into question reliance on unpublished proprietary protocols in areas where there may be safety implications.\n\nThis session should be of interest to anybody interested in the Internet of Things, wireless sensors, embedded systems, hardware hacking, openness and puzzle solving.",
    "title": "Liberating Wireless Sensor Data"
  },
  {
    "day": "day_2",
    "id": 55,
    "presenters": [
      37
    ],
    "room": "great_britain",
    "session": "session_1",
    "text": "Elm is a statically-typed functional language designed for building reliable web applications with \u201cgreat performance and no runtime exceptions\u201d. Elm compiles to Javascript, is easy to embed into existing websites, and has great Javascript interop, meaning that you can use as little or as much Elm as you want in your project. In this talk I\u2019ll introduce the audience to Elm, look at its syntax and tooling, and show where it fits into the larger picture of web development. I\u2019ll also discuss the prescribed method for structuring programs built in Elm, \u201cThe Elm Architecture\u201d. \n\nElm has a great community and excellent documentation, so my goal with this talk isn\u2019t to give a comprehensive lecture on the language. Instead, I want to get you excited about the possibilities of Elm, maybe pique your interest in functional languages, and ultimately get you pointed in the right direction so that you can confidently start to explore Elm for yourself.",
    "title": "Functional Programming for the Web with Elm"
  },
  {
    "day": "day_3",
    "id": 56,
    "presenters": [
      38
    ],
    "room": "bristol_2",
    "session": "session_1",
    "text": "It is good every now and then to pause and take stock, and this applies to ACCU (https://accu.org) too.\nHence the aim of this session is to discuss issues facing the ACCU in a relaxed and informal way. ACCU\nCommittee Members will be on hand to participate in the conversation.  We will seed the session with some\ntopics including:\n\n* how do we widen our appeal;\n* learn about what committee roles entail and how you can\n  contribute; and\n* how to setup a local group.\n\nWe are very interested to hear your concerns and ideas so please bring them along. Members and non-members\nare all welcome.\n",
    "title": "ACCU - The View From The Conference"
  },
  {
    "day": "day_4",
    "id": 57,
    "presenters": [
      39
    ],
    "room": "empire",
    "session": "session_3",
    "text": "ES6 is (almost) the most recent version of the language most commonly known as Javascript. Its publication\nin 2015 was the first update to Javascript since 2009 and brought a number of pretty radical revisions to\nboth language and library.\n\nThis session takes a look at some of the most significant features, the impact they have on the way we write\nJavascript, how we can start using them today, why we should, and a look forward to Javascript's future\nevolution.\n",
    "title": "A Browse Through ES2016"
  },
  {
    "day": "day_4",
    "id": 58,
    "presenters": [
      40
    ],
    "room": "empire",
    "session": "session_2",
    "text": "C++11 gave us lambdas in the language for the first time (if you ignore boost::lambda) - so it's a functional language now, right? There's a bit more to functional programming than having first class function objects. I'd even argue we still don't quite have that. But does that mean we can't do functional programming in C++? Yes. No. Maybe...\n\nFirst we have to define what functional programming actually is - and it may not be quite what you think. Then we need to see what valuable ideas have come out of the functional approach to software design and which ones we can use in C++ to good effect.\n\nIn the end we'll see that, while not strictly a functional programming language, we can get quite a long way with immutable data types, persistent data structures, atomic references, and - if you're not watching carefully - we might even throw the M word in there!\n",
    "title": "Functional C++ For Fun And Profit"
  },
  {
    "day": "day_1",
    "id": 60,
    "presenters": [
      41
    ],
    "room": "bristol_2",
    "session": "session_2",
    "text": "Multithreading in C++ has been used successfully for many years prior to the introduction of C++ 11 to run programs on multi-core hardware.  Then the C++ 11 Memory Model for multithreading was introduced with much debate as to its proper application.  On the one hand some suggest not to bother with atomics and just use volatile if at all.  On the other hand some might be happy to have everything guarded with mutexes.  Either side may have been discouraged from looking deeper into the C++ 11 Memory Model, put off by its apparent complexity.\n    The talk will focus on different options of \u201cmemory order\u201d when using std::atomic.  It'll explain what the memory order is and what each of the options mean.  We'll take a look at the C++ memory model, sequencing of expressions and synchronization between threads.  The talk sheds light on compiler optimizations and generated assembly, examines out-of-order execution in CPUs and possible cache communication between cores.  In the end it should be clear what an atomic variable does apart from storing a value.",
    "title": "Atomic's memory orders, what for?"
  },
  {
    "day": "day_2",
    "id": 61,
    "presenters": [
      42
    ],
    "room": "bristol_1",
    "session": "session_3",
    "text": "The complexity of the C++ language, which allows for versatility and good performance in a range of different domains, results in a steep learning curve and a reputation for being hard to learn and master. The rapid development of C++ with the recent standards C++11, C++14 and C++17 brings a challenge. What is modern C++, how can we keep up, and how can we avoid to learn and teach outdated idioms?\nThe session discusses these challenges and then analyses the different information resources at our disposal, like books and different kinds of online content.",
    "title": "Learning (and teaching) modern C++ - Challenges and Resources"
  },
  {
    "day": "day_3",
    "id": 62,
    "presenters": [
      43
    ],
    "quickie_slot": "slot_1",
    "room": "great_britain",
    "session": "session_1",
    "text": "For many functions which iterate over elements of a node-based container (such as std::list and std::map), the bottleneck is frequently due to accessing data from memory while chasing pointers.  In bidirectional containers, these functions may be rewritten to reduce the number of data dependencies, thereby allowing modern processors to perform more operations in parallel.\n\nIn this session we will rewrite a few methods of std::list to demonstrate some of these techniques and benchmark them against current standard library implementations.",
    "title": "Missing Optimizations on Node-based Containers"
  },
  {
    "day": "day_2",
    "id": 63,
    "presenters": [
      44
    ],
    "room": "bristol_1",
    "session": "session_2",
    "text": "Leading {cpp} experts propose the {cpp} Core Guidelines to foster better coding practices for {cpp}\ndevelopers. The Core Guidelines build around safe coding practices without losing {cpp}'s efficiency, such\nas using const deliberately or minimize the use of raw pointers. Many of the guidelines provide hints for\nenforcing the guideline and some even require or imply effective static analysis tooling to make them\nuseful.\n\nIFS (https://ifs.hsr.ch/index.php?id=5736&no_cache=1&L=4[Institute for Software]) has a long history of\nproviding static analysis within an IDE and also suggesting transformation for improving code, such as,\napplying {cpp}11's initializers, instead of uninitialized or old-fashioned initialized variable\ndeclarations. While already addressing some areas covered by the Core Guidelines, we recently targeted many\nmore of those explicitly and provide corresponding static analysis and quick-fix refactoring support to\nadjust existing {cpp} code toward following the core guidelines.\n\nThis talk will introduce the {cpp} Core Guidelines and demonstrate how you can modernize your code and\nimprove its quality without losing performance through automated tooling built into Cevelop.\n\nTopics covered:\n\n* What are the {cpp} Core Guidelines\n** Philosophy and goals\n** Areas covered\n** Examples\n* Automatic \"repair\" of code\n** const Correctness\n** Constructors/destructors/assignment\n** Pointers and arrays\n* Future work/Outlook\n\nThe audience will get an overview of the {cpp} Core Guidelines. Using practical code examples improvements\nthrough application of the guidelines is demonstrated. Tools will be shown, that aid in detection of\nguideline violation and automatic repair to guideline-conforming code. Attending developers will be enabled\nto apply the Core Guidelines in the future to create or refactor to safer and more maintainable {cpp} code.\n",
    "title": "C++ Core Guidelines - Modernize your C++ Code Base"
  },
  {
    "day": "day_1",
    "id": 65,
    "presenters": [
      45
    ],
    "room": "empire",
    "session": "session_2",
    "text": "Ask programmers what comes to mind when you say concurrency and most are likely to say threads. Ask what comes to mind when you say threads and most are likely to say locks or synchronisation. These assumptions are so deeply held that they define and constrain how programmers are taught and think about concurrency: thread safety is almost synonymous with the avoidance of race conditions and the guarded protection of mutable state. But this is only one quadrant of four possibilities, a quadrant diagram partitioned by mutable\u2013immutable along one axis and shared\u2013unshared along another.\n\nWhether C++, C# or Java, many mainstream languages support programmers in all four quadrants, not just the synchronisation quadrant. From immutability to actors, this talk will take a look at patterns and practices that encourage thinking and coding outside the locked box.",
    "title": "Thinking Outside the Synchronisation Quadrant"
  },
  {
    "day": "day_2",
    "id": 67,
    "presenters": [
      46
    ],
    "room": "great_britain",
    "session": "session_2",
    "text": "Whether we like it or not, most of the programs out there are not deterministic; making developers to take an effort and start thinking about determinism, is known to be difficult.\n\nOn the other hand, the case for deterministic programs is strong, with multiple benefits available for such programs. These benefits include such things as replay-based regression testing using production data, production post-mortem analysis (including both server-side and client-side), low-latency fault tolerance, and so on. \n\nSuch benefits become even more important for interactive distributed systems, where various race conditions tend to represent a lion share of those bugs which manage to slip into production. \n\nFortunately, there exists a very practical approach (which has succeeded for a rather large real-world project) that allows to make components of a distributed system deterministic. \n\nThe talk discusses benefits of deterministic components for distributed systems, different definitions of determinism from practical standpoint, and the way to implement deterministic components (very shortly - good old event-driven programs/ad-hoc FSMs/Reactors plus several tricks to make them deterministic). \n\nLevel: Intermediate/Expert",
    "title": "Deterministic Components for Interactive Distributed Systems: Benefits and Implementation"
  },
  {
    "day": "day_1",
    "id": 68,
    "presenters": [
      47
    ],
    "room": "bristol_1",
    "session": "session_1",
    "text": "C++17 introduces parallel versions of the algorithms into the standard C++ library. The algorithms are intended for the general software development community rather than addressing a few specialists. It is becoming more important for all developers to understand how the parallel algorithms can be used.\n\nDifferent kinds of parallelism are exposed using corresponding execution policies. Each execution policy implies specific constraints for the use of algorithms to enable the respective parallel approaches. The interface for execution policies is described together with the constraints of the defined execution policies.\n\nThis presentation discusses the model behind the parallel algorithms and the associated constraints. Some example uses are shown together with results to motivate the importance of enabling parallelism in programs.\n\nThe current specification is an initial version exposing parallel interfaces and there are some proposals on refining the interface for better support of composition. The direction for making the parallel algorithms asynchronous is described together with some alternatives of how it can be designed.",
    "title": "Parallel Algorithms"
  },
  {
    "day": "day_2",
    "id": 69,
    "presenters": [
      48
    ],
    "room": "bristol_3",
    "session": "session_3",
    "text": "It sounds counter-intuitive, but limiting work in progress actually improves the flow of your team. In this workshop you will experience this firsthand. We will be experimenting with several approaches to increase throughput, without changing the actual work.",
    "title": "Why limiting your work in progress will speed up your project"
  },
  {
    "day": "day_4",
    "id": 70,
    "presenters": [
      49
    ],
    "room": "great_britain",
    "session": "session_3",
    "text": "You've written a function that takes an integer and returns true if that\nnumber is a multiple of both 3 and 5. How will you test it? You could\nthrow every integer at it, but that might take some time...\n\nProperty Based Testing has become increasingly popular of late. It's a\nform of parameterized unit-testing that automatically generates sample\ninputs to a test to try and dis-prove that test's assumptions.\n\nIt grew up in the Functional Programming world (Haskell, specifically)\nbut there's more to it than Functional 'chic'. With adaptations in many\nlanguages and styles, and integration with a plethora of popular testing\nframeworks, programmers of all kinds are finding Property Based Testing\na useful addition to their arsenal.\n\nFor a bit of fun, in this talk I will look at some simple problems that\nlend themselves to being tested this way, rather than, for example, by\nexample-based testing. And since it's enlightening to compare and\ncontrast styles and languages, I'll try and cover some different ones of\nthose, including C++, C#, F#, Python, Ruby, maybe some Scala, perhaps\neven a little Powershell. \n\nNo prior experience is required, but some exposure to automated testing in one or more languages will be helpful. Open to all.",
    "title": "Got To Test Them All"
  },
  {
    "day": "day_3",
    "id": 71,
    "presenters": [
      50
    ],
    "room": "bristol_2",
    "session": "session_3",
    "text": "C++ coroutines have not yet been standardised, but are available today in Visual Studio 2015 (coming soon to clang/llvm) in the form of the stackless coroutines/resumable functions [1] presented at CppCon2016 [2][3][4].\n\nThis session will look beyond the canonical examples of generators and asynchronous IO to see if coroutines can be leveraged in the pursuit of C++ DSLs to make concurrency easier to work with for humans - \"Concurrency at Human Scale\".\n\nAs of writing, the investigations and technology behind this talk are still evolving, so the outcome is not a foregone conclusion.\n\nOther material, illustrating the search for inspiration on how to tackle these problems, may include:\n\nA look at other systems for specifying, testing and reasoning about concurrency such as Leslie Lamport's PlusCal/TLA+ [5] (see also [6]).\n\nA look at the facilities for high level control flow manipulation afforded by other languages and runtime systems such as Racket's first class continuations, continuation marks and prompts [7][8].\n\nA look at other programming models for concurrency including Erlang's actors (in the form of C++ Erlesque Actors [9]), Linda's tuple spaces [10], and Syndicate's coordinated concurrent proramming [11].\n\nLevel: Intermediate to expert\n\nReferences:\n\n[1] Gor Nishanov, Jim Radigan :  Resumable Functions - N4402\nhttps://isocpp.org/files/papers/N4402.pdf\n\n[2] CppCon 2016: Jame McNellis - Introduction to C++ Coroutines\nhttps://www.youtube.com/watch?v=ZTqHjjm86Bw&list=PLHTh1InhhwT7J5jl4vAhO1WvGHUUFgUQH&index=41\n\n[3] CppCon 2016: Kenny Kerr & James McNellis \u201cEmbracing Standard C++ for the Windows Runtime\"\nhttps://www.youtube.com/watch?v=v0SjumbIips&index=61&list=PLHTh1InhhwT7J5jl4vAhO1WvGHUUFgUQH\n\n[4] CppCon 2016: Gor Nishanov \u201cC++ Coroutines: Under the covers\"\nhttps://www.youtube.com/watch?v=8C8NnE1Dg4A&index=87&list=PLHTh1InhhwT7J5jl4vAhO1WvGHUUFgUQH\n\n[5] Leslie Lamport: The PlusCal Algorithm Language\nhttp://research.microsoft.com/en-us/um/people/lamport/tla/pluscal.html\n\n[6] ACCU 2016: Dominic Robinson : Test Driven Specification \u2013 A Gentle Introduction to TLA+ (finding concurrency bugs before you write code)\nhttps://accu.org/index.php/conferences/accu_conference_2016/accu2016_sessions#Test_Driven_Specification_%E2%80%93_A_Gentle_Introduction_to_TLA+_(finding_concurrency_bugs_before_you_write_code)\n\n[7] Continuations in Racket\nhttps://docs.racket-lang.org/reference/cont.html\n\n[8] Mathew Flatt et al : Adding Delimited and Composable Control to a Production Programming Environment\nhttp://www.cs.utah.edu/plt/publications/icfp07-fyff.pdf\n\n[9] ACCU 2014: Dominic Robinson : Comfortable concurrency\nhttps://accu.org/index.php/conferences/accu_conference_2014/accu2014_sessions#comfortable_concurrency\nhttp://www.infoq.com/presentations/concurrency-models\n\n[10] Nichlas Carriero and David Gelernter : Linda in Context\nhttp://www.inf.ed.ac.uk/teaching/courses/ppls/linda.pdf\n\n[11] Tony Garnock-Jones and Matthias Felleisen : Coordinated Concurrent Programming in Syndicate\nhttps://www.google.co.uk/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&uact=8&ved=0ahUKEwjD7M_Fgs7QAhUHCMAKHR8uBucQFggaMAA&url=http%3A%2F%2Fwww.ccs.neu.edu%2Fhome%2Ftonyg%2Fmarketplace%2Fcoordinated-concurrent-programming-in-syndicate-20160111-1409.pdf&usg=AFQjCNGZN1pub5uMIq-Bek7eH7-EuooN4w&bvm=bv.139782543,d.d24",
    "title": "Coroutines and C++ DSLs for Human Scale Concurrency"
  },
  {
    "day": "day_3",
    "id": 72,
    "presenters": [
      51
    ],
    "quickie_slot": "slot_4",
    "room": "bristol_3",
    "session": "session_1",
    "text": "As most developers have experienced, code frequently calls into unreliable agents: databases, remote services and highly inefficient algorithms. The calls can timeout, throw exceptions or return invalid results. The industry has invested much time and money in devising software patterns that attempt to minimise the impact of these routine errors. We propose to record the execution history of such calls for the purpose of assessing the likelihood of a task completing successfully. Our system can decide to cancel a call that is likely to fail in order to save the resource of both the caller and the callee, generally improving system resilience. Additionally, the system validates the results returned from successful calls and provides a recourse mechanism for cancelled calls.  We achieve this by introducing instrumentation that is simple to add to C++ code that provides cancelling logic, validation, and result normalization.",
    "title": "Easy High Constancy"
  },
  {
    "day": "day_3",
    "id": 73,
    "presenters": [
      52
    ],
    "quickie_slot": "slot_3",
    "room": "empire",
    "session": "session_1",
    "text": "Love them or loathe them, passwords are here for the foreseeable future so we really should learn how to deal with them properly. So much of what we think we know about passwords is based on historical half truths, and actually makes how we generally handle them less secure. \n\nIn this session we'll look at how to safely, securely and quickly store passwords for login, and take a look at what implementation details you could be leaking by making people jump through hoops to generate a \"valid\" password.\n\nAimed at all levels from the absolute novice, to the advanced developer who may have picked up some bad habits, this light hearted, language agnostic talk will look at a simple problem that we persist in making hard for ourselves.",
    "title": "Passwords. Are. Not. Hard!"
  },
  {
    "day": "day_3",
    "id": 78,
    "presenters": [
      55
    ],
    "room": "bristol_1",
    "session": "session_1",
    "text": "Contracts programming is based in the idea that any operation has a number of preconditions and postconditions. Different instantiations of this idea have been used in different programming languages (Eiffel, Ada2012, C#).\n\nIn this talk, I will briefly cover the general ideas behind contracts programming. Then I will provide details on how these ideas can be incorporated into C++. I will present also the latest updates on the C++ contracts proposal that is under discussion at the ISO C++ standards committee.\n\nAdditional note: The content of this talk will be influenced by the results of discussions at the March ISO C++ meeting where I will present the proposed wording of the feature.\n\nFor reference, please see the latest ISO C++ paper \"A Contract Design\"\n[http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf]",
    "title": "Contracts programming after C++17"
  },
  {
    "day": "day_4",
    "id": 80,
    "presenters": [
      56,
      57
    ],
    "room": "bristol_2",
    "session": "session_3",
    "text": "Applications wanting to include 3D graphics have mostly had to rely on low level graphics APIs or on a number of higher level scene graph based libraries. Modern day 3D graphics however has increased in complexity and many of the existing C++ libraries have struggled to provide versatility and performance. This is likely to become even more problematic with the growth of Virtual Reality and Augmented Reality.\n\nQt 5.7 introduces Qt3D, a new library for integrating 3D real time rendering in C++ application. Qt 3D is structured around an Entity Component System (ECS) architecture which will be introduced. We will present how to add custom  geometries and materials to your scene, or how to deal with user's input.\n\nFurthermore, we will show how the ECS architecture has been used in two useful ways.  First, data related to entities and components can be very easily be modelled in a declarative language like QML (which has been key to Qt\u2019s recent development), enabling unprecedented ease of use for complex rendering techniques. Second, the separation of data and operations has facilitated the  creation of a highly concurrent simulation engine, enabling the integration of many different algorithms.\n\nThis talk will be interesting to any developer having to implement a 3D scene inside an application (whether already using Qt, or evaluating various technologies for this job). No prior knowledge of OpenGL or GPU programming is required for this talk.",
    "title": "Introduction to Qt 3D"
  },
  {
    "day": "day_1",
    "id": 81,
    "presenters": [
      58
    ],
    "room": "bristol_3",
    "session": "session_1",
    "text": "To most of us the linker is a tool that combines the output of many compilations into a single output file,\nbut to many its inner workings are a mystery.\n\nIn this session we'll deconstruct the linking process to reveal:\n\n- The component parts of an object file and how they map to your C/C++ source code.\n- How a linker finds all the content your program needs.\n- How the linker generates code and data to support dynamic linking, position independent code, and thread-local storage.\n- How a linker combines all the component parts into a single file.\n- How link time optimisation works.\n\nWe'll be concentrating on the ELF object file format, using the System V dynamic linking conventions. The\ndetails of linking on Windows are different, but the underlying concepts are similar.\n\nThe talk is suitable for intermediate developers with a working knowledge of C, ideally on a Unix like\nsystem. No prior knowledge of linkers is assumed.\n",
    "title": "The link from object to executable - the role of linker in a development toolchain"
  },
  {
    "day": "day_4",
    "id": 83,
    "presenters": [
      60
    ],
    "room": "bristol_3",
    "session": "session_1",
    "text": "Traditionally, memory usage analysis and memory leak analysis for C and C++\nprograms involve instrumenting either source code or binary code before\nrunning it through a series of tests.  Such an approach, depending on how\naggressively the code is instrumented, either results in false leaks, if the\ncode is not sufficiently instrumented to completely understand whether\nallocations are still in use, or distorts the timing so much that it is not\npractical to run on a regular basis.  What is worse, if the memory usage of\ninterest happened using code that was not instrumented, it may not be practical\nto reproduce the problem, for example due to dependence on some obscure code\npath or on some test that is expensive to run.\n\nAt VMware I have developed a tool called ah64 that avoids these issues by\nanalyzing un-instrumented core files, either live cores or cores from\ncrashes, for leaks and memory usage and corruption.  It does not report any\nfalse leaks and is sufficiently reliable that we run it in an automated way\nto catch leaks before they are checked in to our code base.  We also use it\nregularly to understand memory growth issues and cases of memory corruption.\n\nVMware is making this available as open source.  At present it is working only\nfor Linux ELF cores generated with programs that use libc malloc, and mostly\nworking with windows MDMP files.  Some expected areas of growth are likely to\ninclude support for other allocators, such as tcmalloc and jemalloc, support\nfor other dump formats, better scripting, and use of DWARF information to make usage analysis more precise.",
    "title": "ah64: A memory analyzer for un-instrumented cores"
  },
  {
    "day": "day_1",
    "id": 85,
    "presenters": [
      61
    ],
    "room": "bristol_1",
    "session": "session_2",
    "text": "Hidden in the Library fundamentals Technical Specification, there is a section called \"Detection idiom\". The specification doesn't really say what it is for, and it has not received a lot of notice.\n\nThat's a shame. This is an amazingly powerful method for distinguishing between kinds of types. Writing SFINAE constraints is tedious and confusing, and this will make them much easier to do.\n\nThis session will introduce the detection idiom, talk about how it works, and then give examples on how to use it.\n\nA basic knowledge of template meta-programming will be useful",
    "title": "The Detection Idiom - a simpler way to SFINAE"
  },
  {
    "day": "day_2",
    "id": 86,
    "presenters": [
      62
    ],
    "room": "empire",
    "session": "session_2",
    "text": "http://kotlinlang.org[Kotlin] is a new programming language for the JVM (and JavaScript VM) by JetBrains. It\nis a statically typed language designed to include the most pragmatic features from Java, Groovy, C# and\nScala. Kotlin is what Java 9 should have been in an ideal world.\n\nThis session is an overview of Kotlin features using code examples and comparison with other JVM languages.\nThe idea is to move from compiling and running \"hello world\" to more advanced examples, encounter some\nKotlin puzzlers along the way and finish with actual program written in Kotlin (most likely Snake game).\n\nTarget audience: software developers (with basic knowledge of Java/Groovy/Scala syntax).\n",
    "title": "An introduction to Kotlin by example"
  },
  {
    "day": "day_3",
    "id": 88,
    "presenters": [
      63,
      64
    ],
    "quickie_slot": "slot_1",
    "room": "bristol_3",
    "session": "session_1",
    "text": "Clang - is the name of the C/C++ frontend in LLVM project. It has many powerful features and one of them is its design. It was written in a way that allows to use it inside any IDE as a provider for various things - from navigation and code completion to refactorings. But is it possible to use it with the modern Java IDE? That is the question we will answer in this session. Our team spent some time porting Clang into Java. We will tell you how it was done, what difficulties we faced and what outcome we have at this point.",
    "title": " LLVM C/C++ compiler frontend in Java"
  },
  {
    "day": "day_3",
    "id": 89,
    "presenters": [
      65
    ],
    "room": "bristol_1",
    "session": "session_3",
    "text": "The addition of `std::variant` to the upcoming C++17 standard will introduce a \"type-safe sum type\" to the STL. \nGiven a set of types, `std::variant` (and `boost::variant`) model an ADT (\"algebraic data type\") where only one of them can be active: they essentially are a type-safe \"tagged union\". \n\nThe interface they provide, however, is more cumbersome than it needs to be and doesn't lend itself to monadic composition. Defining exhaustive visitors requires the user to create a class with several `operator()` overloads, or to create a chain of `if constexpr(...)` calls. Both solutions are not very elegant.\n\nAfter a brief overview of `std::variant` and its usefulness, this talk will focus on the implementation of a \"lambda-based in-place visitation\" approach, where the user can visit a variant by simply providing a set of overloaded lambdas on the spot.\n\nDon't be fooled, though - the implementation will not be as simple as it sounds. The talk will cover:\n\n* Traditional non-recursive variant visitation.\n* Lambda-based non-recursive variant visitation.\n** The implementation of an \"overload set\" generator will be analyzed.\n* Traditional recursive variant visitation.\n* Lambda-based recursive variant visitation.\n** The implementation of a \"Y-Combinator\" will be analyzed and benchmarked against `std::function`.\n** Callable object arity deduction techniques will be implemented and applied to make the user interface more elegant.\n\nThis talk is intended for an audience familiar with C++11 and C++14 core language features.",
    "title": "Implementing `variant` visitation using lambdas"
  },
  {
    "day": "day_2",
    "id": 91,
    "presenters": [
      67
    ],
    "room": "empire",
    "session": "session_3",
    "text": "2017 sees the 30th anniversary of RFC1035, the RFC that defined the Internet\nDomain Name System (DNS). These days there can't be many applications that\ndon't interact with a DNS nameserver at some point, and as proven by the\nrecent Dyn DDoS attack, DNS is a critical part of Internet infrastructure.\n\nHowever, the only change visible to most developers in recent years has been\nencouragement to switch from `gethostbyname()` to `getaddrinfo()`, so you\nmight be forgiven for thinking that nothing much has changed in DNS in the\nlast thirty years.\n\nNot so. After a shaky start, crypto authenticated DNS, DNSSEC, is gaining\ntraction, and there are some potentially important services defined on top of\nDNSSEC such as DANE, using DNSSEC as an alternative chain of trust to\ncertificate authorities. There is also work in progress on DNS Privacy, or\npreventing snooping on DNS queries.\n\nIn this session, suitable for all-comers, we'll begin with a look at how DNS\nworks currently, and then go on to look at DNSSEC and other recent and\nin-progress developments. We'll see how to sign your domain with DNSSEC, how\nto use DNSSEC and other new technologies in your application, and try to\nanswer any questions you may ever have had about\nDNS.\n",
    "title": "DNS at 30"
  },
  {
    "day": "day_3",
    "id": 93,
    "presenters": [
      69
    ],
    "room": "bristol_1",
    "session": "session_2",
    "text": "Almost every C/C++ programmer eventually runs into a situation when they have to write a lot of boilerplate code. Enum to string conversion (and vice versa), data serialization/deserialization, remoting proxy/stubs are the most common cases. There is a number of different techniques to reduce the effort to produce this kind of code, such as macros metaprogramming, templates metaprogramming, tricks with files inclusion, special DSL with converters and so on.\n\nThis talk introduces one such technique based on clang 3.9 front-end and its special 'libtooling' library. It describes an easy method to analyze the existing C++ sources and to produce another set of C++ sources for specified task (for instance, enum to string converters). Development of a clang-based tool \"from scratch\" is introduced, including command line options analysis, clang compiler invocation, AST investigation, result code generation, etc. Also, the method for custom tool integration into the CMake-based build system is presented. The talk is illustrated with simple examples, which can be useful for making your own custom clang-based tools. Write less code and enjoy!",
    "title": "Automatic C++ source code generation with clang"
  },
  {
    "day": "day_4",
    "id": 94,
    "presenters": [
      70
    ],
    "room": "bristol_2",
    "session": "session_1",
    "text": "Creating and maintaining a FOSS project is time consuming, but easy.  Getting users and popularity, is a bit\nharder.  Targeting C and {cpp} developers as users, in the developer tools (devtools) space, that is really\ntough.  And if we are talking about creating the \"missing link\" of dev tools, a C and {cpp} package manager,\nit becomes \"Mission: Impossible\"\n\nThis talk will summarize my experience, from founding a venture capital backed startup called\nhttp://biicode.com[biicode], then closing it, to finally creating https://www.conan.io/[Conan], a FOSS\nproject recently acquired by JFrog.  I will try to offer my insights to some of the following questions, as\nwell as any other the audience might have:\n\n- How to choose a project? How hard is dev-tools?\n- How do you choose the stack?\n- Do you need financial support for your OSS project?\n- Is it possible to bootstrap your project?\n- What do investors and VC think of OSS?\n- How to find co-creators/maintainers? Do you need them?\n- How to get feedback, filter and prioritize features?\n- An absolutely necessary skill: How to say no to users.\n- How to promote your project? Dos and don'ts\n- Does the project needs devops, release, sysadmin, services?\n- How to manage work/life balance? Holidays, what holidays?\n- How to make money? What are the goals of the project?\n- Is there a business model?\n\nThis talk will deep dive into the unknown parts of OSS development, more specifically in the space of\ndevtools, and all the important lessons learnt in the process.\n\nThis talk is inspired by last Accu 2016 talk by A. Bryce \"How I Went from {cpp} Programmer to Running My Own\nSoftware Product Company\"\n",
    "title": "5 years creating FOSS dev tools for C and C++: the untold"
  },
  {
    "day": "day_3",
    "id": 95,
    "presenters": [
      71
    ],
    "quickie_slot": "slot_1",
    "room": "empire",
    "session": "session_1",
    "text": "Fenwick tree (sometimes also called binary indexed tree, or BIT) is a data structure that deserves to be much more well known among software developers.\n\nInvented by Peter M. Fenwick in 1994, it allows updating of elements in an array and computing sums of arbitrary contiguous blocks of the array, both in time proportional to the logarithm of the length of the array. The magic bit is that the tree lives in the same array and does not take any extra memory!\n\nOriginally designed to support frequency counting in arithmetic compression, another usage example is mapping between screen positions and row numbers in a table where row heights may change.",
    "title": "Efficient data aggregation with Fenwick trees"
  },
  {
    "day": "day_2",
    "id": 98,
    "presenters": [
      74
    ],
    "room": "bristol_2",
    "session": "session_1",
    "text": "Are memory allocators worth the trouble? What situations merit their use? How are they applied effectively? What\u2019s the performance impact? This practical talk by large-scale C++ expert John Lakos demonstrates that having *local memory allocators* in your tool box may lead to as much as *order-of-magnitude speed improvements*.\n\nThe runtime implications of the physical location of allocated memory are sometimes overlooked\u2014even in the most performance-critical code. In this talk, we will examine how the performance of long-running systems can degrade when using just one global allocator (e.g., via new/delete). We will contrast the use of global allocators with various kinds of local allocators\u2014allocators that allocate memory for a well-defined subset of objects in the system.  We will also demonstrate how local allocators can reduce, if not entirely prevent, degradation seen in systems that rely solely on the global allocator. Six dimensions\u2014_fragmentability_, _allocation density_, _variation_, _utilization_, _locality_, and _contention_\u2014will be introduced to help ",
    "title": "Local (arena) Memory Allocators"
  },
  {
    "day": "day_2",
    "id": 99,
    "presenters": [
      75
    ],
    "room": "bristol_2",
    "session": "session_2",
    "text": "Making programs run as efficiently as possible is a popular topic in C++; it being a fairly low-level language, it is indeed particularly well suited to mapping algorithms to the architecture that evaluates them with minimal overhead. Making that mapping as optimized as possible is a vast domain, which this talk merely introduces by presenting an overview compiling various techniques, their reasoning, when they can be applied, and the challenges associated with generalizing them throughout your source code.\n\nThe first part of this talk will focus on understanding the architecture, from which we will deduce what properties code needs to satisfy in order to map efficiently to it, and will cover aspects such as NUMA, multi-core, superscalar execution, instruction pipelining, specialized processing units, caching behavior and branch prediction.\n\nThe second part of the talk will present actual programming techniques that can be used to make use of the previously introduced properties, among others: asynchronous programming, strength reduction, tiling, loop unrolling and pipelining, branch elimination, vectorization, mixed precision and specialized algorithms. For each of those we will discuss how C++ templates can help in generalizing and combining those techniques.\n\nFinally we will take a look at some benchmarks to assess how useful those techniques ended up being on particular use cases.",
    "title": "An Overview of Program Optimization Techniques"
  },
  {
    "day": "day_3",
    "id": 101,
    "presenters": [
      76
    ],
    "quickie_slot": "slot_4",
    "room": "great_britain",
    "session": "session_1",
    "text": "In this session we will use clang's features to find bugs at compile time (via static analysis) and runtime (via sanitizers). First we will look how clang is able to detect common C/C++ traps and pitfalls via static analysis. We will write our own code checker to implement a common C++ guideline. Second, we will demonstrate sanitizers which enable code instrumentation and detection of problems which happen at runtime.",
    "title": "linting with clang and clang-tidy"
  },
  {
    "day": "day_4",
    "id": 102,
    "presenters": [
      77
    ],
    "room": "bristol_1",
    "session": "session_1",
    "text": "Strings tend to be an under-appreciated but very important part in modern code. Whenever you deal with human input, your code probably has to deal with strings at some point. C++ and the STL have traditionally been lagging behind other languages and their standard libraries, especially scripting languages, in allowing rich operations on strings. But things have changed with recent standards: processing strings has become both attractive and fast.\n\nIn this talk I'll talk about dealing with strings, while keeping performance in mind. Why is optimizing string access important? What about string encoding? What if strings are connected to other data structures? What makes string operations slow and how do I avoid that?",
    "title": "Dealing with strings in C++"
  },
  {
    "day": "day_1",
    "id": 104,
    "presenters": [
      79
    ],
    "room": "bristol_2",
    "session": "session_1",
    "text": "Lock-free programming is an important technique for writing thread-safe code for low-latency and real-time applications. It is also often regarded as challenging and notoriously hard to get right. But it doesn't always have to be that way! This talk gives an accessible but comprehensive introduction to the subject.\n\nA lot of material has been published on lock-free programming already. However, the modern C++ standard has significantly improved the situation by introducing an inherently thread-safe generic type \u2013 std::atomic \u2013 and a well-defined memory model for multithreaded code. It is therefore worth approaching the topic of lock-free programming from the perspective of modern standard C++. In fact, all code examples in this talk will be standard-conforming, portable C++11/14, and we won't discuss  platform-specific solutions.\n\nThe talk will start by motivating lock-free programming and its use cases. I will then clarify the meaning of terms like atomic, lock-free, and wait-free. Diving into some actual code, we will discuss the usage of std::atomic, its member functions, its template specialisations, compare-exchange operations, and common pitfalls.\n\nIn the main part of the talk, I will then show various common use-cases of lock-free programming. We will discuss useful and generic ways to safely share and move data across threads without locks and critical sections. We will also work through the implementation of a lock-free data structure: the lock-free queue (also known as fifo or ring buffer). This will serve as an example of how lock-free structures work, when they're useful, and what to watch out for.",
    "title": "Lock-free programming with modern C++"
  },
  {
    "day": "day_1",
    "id": 105,
    "presenters": [
      80
    ],
    "room": "empire",
    "session": "session_1",
    "text": "When it comes to writing tests we often live in the here-and-now and consequently end up producing \"write-only\" tests. This session looks at what we need to consider if we want to create tests that our future selves and teammates will find valuable instead of becoming another burden on top of delivering the feature itself.\n\nIf there is one place that we find it easy to take shortcuts it's when writing tests. Whether we're under the cosh or have an overly-optimistic view of our ability to write self-documenting code, instead of creating tests that support the production code and development process we can find ourselves producing WTFs (Weak Test Functions). The net effect is often a viscious cycle that disparages, instead of encourages us.\n\nIn the past I've tried many different ways to try and short-circuit the test writing process, but have only come up short every time. This session takes a look at why skimping on elements of the test structure, such as organisation, naming and scope only leads to pain and hardship in the long run. Along the way we'll uncover the truth behind common folklore, such as only having one assertion per test.",
    "title": "A Test of Strength"
  },
  {
    "day": "day_4",
    "id": 106,
    "presenters": [
      81
    ],
    "room": "great_britain",
    "session": "session_2",
    "text": "High-Frequency Trading (HFT) and low-latency trading are becoming one of the few preserves of C++. The fact that it is amenable to extensive optimisation, including micro-optimisations, has made it highly effective, some of the major trading systems are hybrid FGPA/C++ solutions or native C++ solutions.\n\nBy popular demand this talk will be an expanded and updated version of that given to ACCU/London! I shall provide an analysis of some micro-optimisation techniques that have been successfully used, but also an investigation of the pitfalls that may arise. For example: Performance anomalies lead to a discovery of quirks in generated assembler due to different compiler versions. Exactly what is static branch-prediction, and how is it (ab)used? Why is counting the number of set bits of the remotest interest? And the \"curious case of the switch-statement\" will be investigated. How fast can one create a FIX message (involving adventures in std::memcpy!)?",
    "title": "Knuth, Amdahl: I spurn thee!"
  },
  {
    "day": "day_2",
    "id": 107,
    "presenters": [
      82
    ],
    "room": "bristol_3",
    "session": "session_1",
    "text": "Documentation\u2019s lack of popularity among programmers is at least partly due to time wasted on too much documentation, and producing docs the hard way. However, neglecting software documentation and technical writing skills holds us and our projects back. The solution is to improve basic skills, integrate documentation with modern software development methods, and learn about modern tools. Topics include:\n\n* Documentation requirements - understanding why we need system documentation\n* Content guidelines - deciding what to document\n* Technical writing - learning techniques for effective writing\n* Documentation types - comparing essential documentation with special-purpose docs\n* Production pipelines - using tools to produce software documentation\n* Architecture and code improvements - reducing the need for documentation\n* Project management - agile documentation planning and project risk reduction\n\nThis workshop teaches what to document, what not to, and how to produce documentation without the pain of traditional approaches. Attendees will learn to write and publish effective documentation with less effort, and develop a long-term skill. This benefits all software development teams, because good system documentation is a universal software requirement.",
    "title": "Documentation for software developers"
  },
  {
    "day": "day_4",
    "id": 111,
    "presenters": [
      86
    ],
    "room": "bristol_2",
    "session": "session_2",
    "text": "C++17 is adding parallel overloads of most of the Standard Library algorithms. There is a TS for Concurrency in C++ already published, and a TS for Coroutines in C++ and a second TS for Concurrency in C++ in the works.\n\nWhat does all this mean for programmers? How are they all related? How do coroutines help with parallelism?\n\nThis session will attempt to answer these questions and more. We will look at the implementation of parallel algorithms, and how continuations, coroutines and work-stealing fit together. We will also look at how this meshes with the Grand Unified Executors Proposal, and how you will be able to take advantage of all this as an application developer.",
    "title": "Concurrency, Parallelism and Coroutines"
  },
  {
    "day": "day_3",
    "id": 114,
    "presenters": [
      89
    ],
    "room": "great_britain",
    "session": "session_3",
    "text": "\nC++ has seen a fast paced evolution over the last six years, giving performance oriented programmers access to high level features such as range based loops, automatic type deduction, lambdas and unprecedented compile time expressivity. The core guidelines has emerged as a manual for using the new language features to write  type safe code without sacrificing performance or control.\nBut the moment you want to interact directly with the operating system, to get block level access to a hard drive, interact with the file system directly, create a timer or set up a TCP server, it\u2019s a blast from the past with good old POSIX. Brimming with macro magic, pointer / size- and even pointer-to-pointer interfaces and a very unnecessary amount of blocking calls, it\u2019s obvious that a modern C++ implementation of the same functionality can be done much better, cleaner and safer.\nIn IncludeOS we\u2019re working on just that - we\u2019re implementing POSIX because we realize there\u2019s no way around it, but we\u2019ve decided to create a modern C++ interface for every new feature first, and then wrap the old interface around that as an optional layer.\nIn this talk we\u2019ll show you our take on the virtual file system (mount a lambda or a const float safely on any file system path!), why integer-based file descriptors are all wrong, how we approach sockets, threading, asynchronicity and more.",
    "title": "POSIX violates core guidelines: A new take on the operating system interface"
  }
]

}
